##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.40A/W32 EVALUATION    24/Sep/2006  17:30:00 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  E:\ARM\IDLEHOOK\main.c                               #
#    Command line    =  E:\ARM\IDLEHOOK\main.c -lC                           #
#                       E:\ARM\IDLEHOOK\Release\List\ -o                     #
#                       E:\ARM\IDLEHOOK\Release\Obj\ -s9 --no_unroll         #
#                       --cpu_mode arm --endian little --cpu ARM926EJ-S      #
#                       --stack_align 4 --interwork -e --fpu None -I         #
#                       D:\IARARM\ARM\INC\                                   #
#    List file       =  E:\ARM\IDLEHOOK\Release\List\main.lst                #
#    Object file     =  E:\ARM\IDLEHOOK\Release\Obj\main.r79                 #
#                                                                            #
#                                                                            #
##############################################################################

E:\ARM\IDLEHOOK\main.c
      1          #include "..\swilib.h"
      2          
      3          #define UPDATE_TIME (1*262)
      4          #define WIDTH 50
      5          #define HIGHT 20
      6          #define X 131-50
      7          #define Y 132
      8          
      9          #define RGB8(R,G,B) (B+(G<<2)+(R<<5))
     10          
     11          CSM_DESC icsmd;
     12          
     13          int (*old_icsm_onMessage)(CSM_RAM*,GBS_MSG*);
     14          
     15          GBSTMR mytmr;
     16          
     17          WSHDR *ws1;
     18          
     19          unsigned char hhh;
     20          char cop;
     21          
     22          unsigned char img1_bmp[WIDTH*HIGHT-1];
     23          

   \                                 In segment DATA_C, align 4, align-sorted
     24          const IMGHDR img1=
   \                     img1:
   \   00000000   32140500           DC8 50, 20, 5, 0
   \   00000004   ........           DC32 img1_bmp

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     img1_bmp:
   \   00000000                      DS8 1000
   \                     icsmd:
   \   000003E8                      DS8 40
   \                     old_icsm_onMessage:
   \   00000410                      DS8 4
   \                     ws1:
   \   00000414                      DS8 4
   \                     hhh:
   \   00000418                      DS8 1
   \                     cop:
   \   00000419                      DS8 1
   \   0000041A                      DS8 2
     25          {
     26            WIDTH,
     27            HIGHT,
     28            5,
     29            0,
     30            (char *)img1_bmp
     31          };
     32          
     33          unsigned char loads[WIDTH-1];
   \                     loads:
   \   0000041C                      DS8 52
     34          unsigned char clocks[WIDTH-1];
   \                     clocks:
   \   00000450                      DS8 52
   \                     mytmr:
   \   00000484                      DS8 16
     35          

   \                                 In segment CODE, align 4, keep-with-next
     36          DrwImg(IMGHDR *img, int x, int y, int *pen, int *brush)
     37          {
   \                     DrwImg:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   2CD04DE2           SUB      SP,SP,#+44
   \   00000008   3C609DE5           LDR      R6,[SP, #+60]
   \   0000000C   0040A0E1           MOV      R4,R0
     38            RECT rc;
     39            DRWOBJ drwobj;
     40            StoreXYWHtoRECT(&rc,x,y,img->w,img->h);
   \   00000010   0100D4E5           LDRB     R0,[R4, #+1]
   \   00000014   0350A0E1           MOV      R5,R3
   \   00000018   01002DE9           PUSH     {R0}
   \   0000001C   0030D4E5           LDRB     R3,[R4, #+0]
   \   00000020   04008DE2           ADD      R0,SP,#+4
   \   00000024   330100EF           SWI      +307
     41            SetPropTo_Obj5(&drwobj,&rc,0,img);
   \   00000028   0430A0E1           MOV      R3,R4
   \   0000002C   0020A0E3           MOV      R2,#+0
   \   00000030   04108DE2           ADD      R1,SP,#+4
   \   00000034   0C008DE2           ADD      R0,SP,#+12
   \   00000038   510100EF           SWI      +337
     42            SetColor(&drwobj,pen,brush);
   \   0000003C   0620A0E1           MOV      R2,R6
   \   00000040   0510A0E1           MOV      R1,R5
   \   00000044   0C008DE2           ADD      R0,SP,#+12
   \   00000048   4B0100EF           SWI      +331
     43            DrawObject(&drwobj);
   \   0000004C   0C008DE2           ADD      R0,SP,#+12
   \   00000050   2A0100EF           SWI      +298
     44          }
   \   00000054   30D08DE2           ADD      SP,SP,#+48
   \   00000058   7080BDE8           POP      {R4-R6,PC}       ;; return
     45          

   \                                 In segment CODE, align 4, keep-with-next
     46          void TimerProc(void)
     47          {
   \                     TimerProc:
   \   00000000   00402DE9           PUSH     {LR}
     48            GBS_SendMessage(MMI_CEPID,0xDEAD,GetCPULoad());
   \   00000004   5D0000EF           SWI      +93
   \   00000008   0020A0E1           MOV      R2,R0
   \   0000000C   AD10A0E3           MOV      R1,#+173
   \   00000010   DE1C81E3           ORR      R1,R1,#0xDE00
   \   00000014   0900A0E3           MOV      R0,#+9
   \   00000018   420C80E3           ORR      R0,R0,#0x4200
   \   0000001C   000100EF           SWI      +256
     49            GBS_StartTimerProc(&mytmr,UPDATE_TIME,TimerProc);
   \   00000020   ........           LDR      R2,??DataTable1  ;; TimerProc
   \   00000024   0C009FE5           LDR      R0,??TimerProc_0  ;; img1_bmp + 1156
   \   00000028   0610A0E3           MOV      R1,#+6
   \   0000002C   401F81E3           ORR      R1,R1,#0x100
   \   00000030   4D0000EF           SWI      +77
   \   00000034   0080BDE8           POP      {PC}             ;; return
   \                     ??TimerProc_0:
   \   00000038   ........           DC32     img1_bmp + 1156
     50          }
     51          
     52          

   \                                 In segment CODE, align 4, keep-with-next
     53          int MyIDLECSM_onMessage(CSM_RAM* data,GBS_MSG* msg)
     54          {
   \                     MyIDLECSM_onMessage:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0060A0E1           MOV      R6,R0
     55            int csm_result;
     56            unsigned int x;
     57          #define idlegui_id (((int *)data)[DISPLACE_OF_IDLEGUI_ID/4])
     58          
     59            //Накапливаем значения
     60            if (msg->msg==0xDEAD)
   \   00000008   04429FE5           LDR      R4,??MyIDLECSM_onMessage_0  ;; img1_bmp
   \   0000000C   0150A0E1           MOV      R5,R1
   \   00000010   040095E5           LDR      R0,[R5, #+4]
   \   00000014   AD10A0E3           MOV      R1,#+173
   \   00000018   DE1C81E3           ORR      R1,R1,#0xDE00
   \   0000001C   010050E1           CMP      R0,R1
   \   00000020   2000001A           BNE      ??MyIDLECSM_onMessage_1
     61            {
     62              LockSched();
   \   00000024   460100EF           SWI      +326
     63              loads[hhh]=HIGHT*/*GetCPULoad()*/msg->submess/100;
   \   00000028   081095E5           LDR      R1,[R5, #+8]
   \   0000002C   1804D4E5           LDRB     R0,[R4, #+1048]
   \   00000030   1420A0E3           MOV      R2,#+20
   \   00000034   920101E0           MUL      R1,R2,R1
   \   00000038   D8219FE5           LDR      R2,??MyIDLECSM_onMessage_0+0x4  ;; 0x51eb851f
   \   0000003C   040080E0           ADD      R0,R0,R4
   \   00000040   9231C5E0           SMULL    R3,R5,R2,R1
   \   00000044   C552A0E1           ASR      R5,R5,#+5
   \   00000048   A11F85E0           ADD      R1,R5,R1, LSR #+31
   \   0000004C   1C14C0E5           STRB     R1,[R0, #+1052]
     64              clocks[hhh]=GetCPUClock()/14;
   \   00000050   5C0000EF           SWI      +92
   \   00000054   1814D4E5           LDRB     R1,[R4, #+1048]
   \   00000058   BC219FE5           LDR      R2,??MyIDLECSM_onMessage_0+0x8  ;; 0x92492493
   \   0000005C   041081E0           ADD      R1,R1,R4
   \   00000060   9230C5E0           SMULL    R3,R5,R2,R0
   \   00000064   005085E0           ADD      R5,R5,R0
   \   00000068   C551A0E1           ASR      R5,R5,#+3
   \   0000006C   A00F85E0           ADD      R0,R5,R0, LSR #+31
   \   00000070   5004C1E5           STRB     R0,[R1, #+1104]
     65              UnlockSched();
   \   00000074   470100EF           SWI      +327
     66              hhh++;
   \   00000078   1804D4E5           LDRB     R0,[R4, #+1048]
   \   0000007C   010080E2           ADD      R0,R0,#+1
   \   00000080   1804C4E5           STRB     R0,[R4, #+1048]
     67              if (hhh>=WIDTH) {hhh=0; cop=1;}
   \   00000084   FF0000E2           AND      R0,R0,#0xFF
   \   00000088   320050E3           CMP      R0,#+50
   \   0000008C   0300003A           BCC      ??MyIDLECSM_onMessage_2
   \   00000090   0000A0E3           MOV      R0,#+0
   \   00000094   1804C4E5           STRB     R0,[R4, #+1048]
   \   00000098   0100A0E3           MOV      R0,#+1
   \   0000009C   1904C4E5           STRB     R0,[R4, #+1049]
     68              csm_result=0;
   \                     ??MyIDLECSM_onMessage_2:
   \   000000A0   0050A0E3           MOV      R5,#+0
   \   000000A4   040000EA           B        ??MyIDLECSM_onMessage_3
     69            }
     70            else
     71              csm_result=old_icsm_onMessage(data,msg); //Вызываем старый обработчик событий
   \                     ??MyIDLECSM_onMessage_1:
   \   000000A8   102494E5           LDR      R2,[R4, #+1040]
   \   000000AC   0510A0E1           MOV      R1,R5
   \   000000B0   0600A0E1           MOV      R0,R6
   \   000000B4   32FF2FE1           BLX      R2
   \   000000B8   0050A0E1           MOV      R5,R0
     72            if (IsGuiOnTop(idlegui_id)) //Если IdleGui на самом верху
   \                     ??MyIDLECSM_onMessage_3:
   \   000000BC   2C0096E5           LDR      R0,[R6, #+44]
   \   000000C0   350100EF           SWI      +309
   \   000000C4   000050E3           CMP      R0,#+0
   \   000000C8   4F00000A           BEQ      ??MyIDLECSM_onMessage_4
     73            {
     74              GUI *igui=GetTopGUI();
   \   000000CC   4D0100EF           SWI      +333
     75              if (igui) //И он существует
   \   000000D0   000050E3           CMP      R0,#+0
   \   000000D4   4C00000A           BEQ      ??MyIDLECSM_onMessage_4
     76              {
     77                void *idata;
     78                idata=GetDataOfItemByID(igui,2);
   \   000000D8   0210A0E3           MOV      R1,#+2
   \   000000DC   4F0100EF           SWI      +335
     79                if (idata)
   \   000000E0   000050E3           CMP      R0,#+0
   \   000000E4   4800000A           BEQ      ??MyIDLECSM_onMessage_4
     80                {
     81          	void *canvasdata=((void **)idata)[DISPLACE_OF_IDLECANVAS/4];
     82          	int y;
     83          	DrawCanvas(canvasdata,X,Y,X+WIDTH,Y+HIGHT,1);
   \   000000E8   0110A0E3           MOV      R1,#+1
   \   000000EC   02002DE9           PUSH     {R1}
   \   000000F0   8330A0E3           MOV      R3,#+131
   \   000000F4   8420A0E3           MOV      R2,#+132
   \   000000F8   9810A0E3           MOV      R1,#+152
   \   000000FC   02002DE9           PUSH     {R1}
   \   00000100   180090E5           LDR      R0,[R0, #+24]
   \   00000104   5110A0E3           MOV      R1,#+81
   \   00000108   250000EF           SWI      +37
     84          	//рисуем нашу требуху
     85          	//     zeromem(img1_bmp,sizeof(img1_bmp));
     86          	int h=hhh;
   \   0000010C   1804D4E5           LDRB     R0,[R4, #+1048]
     87          	for(x=0;x<WIDTH;x++){
   \   00000110   B610A0E3           MOV      R1,#+182
   \   00000114   C01F81E3           ORR      R1,R1,#0x300
   \   00000118   041081E0           ADD      R1,R1,R4
   \   0000011C   3220A0E3           MOV      R2,#+50
   \   00000120   08D08DE2           ADD      SP,SP,#+8
     88          	  for(y=0;y<HIGHT;y++){
   \                     ??MyIDLECSM_onMessage_5:
   \   00000124   0030A0E3           MOV      R3,#+0
     89          	    if (y<loads[h]){
   \                     ??MyIDLECSM_onMessage_6:
   \   00000128   1C60A0E3           MOV      R6,#+28
   \   0000012C   406E86E3           ORR      R6,R6,#0x400
   \   00000130   046086E0           ADD      R6,R6,R4
   \   00000134   0660D0E7           LDRB     R6,[R0, +R6]
   \   00000138   060053E1           CMP      R3,R6
   \   0000013C   030000AA           BGE      ??MyIDLECSM_onMessage_7
     90          	      img1_bmp[x+(HIGHT-1-y)*WIDTH]=RGB8(clocks[h],0,0);
   \   00000140   046080E0           ADD      R6,R0,R4
   \   00000144   5064D6E5           LDRB     R6,[R6, #+1104]
   \   00000148   8662A0E1           LSL      R6,R6,#+5
   \   0000014C   000000EA           B        ??MyIDLECSM_onMessage_8
     91          	    }else{
     92          	      img1_bmp[x+(HIGHT-1-y)*WIDTH]=RGB8(6,0,0);
   \                     ??MyIDLECSM_onMessage_7:
   \   00000150   C060A0E3           MOV      R6,#+192
   \                     ??MyIDLECSM_onMessage_8:
   \   00000154   ........           STRB     R6,[R1], #-50
     93          	    }
     94          	  }
   \   00000158   013083E2           ADD      R3,R3,#+1
   \   0000015C   140053E3           CMP      R3,#+20
   \   00000160   F0FFFFBA           BLT      ??MyIDLECSM_onMessage_6
     95          	  h++;
   \   00000164   010080E2           ADD      R0,R0,#+1
     96          	  if (h>=WIDTH) h=0;
   \   00000168   320050E3           CMP      R0,#+50
   \   0000016C   0000A0A3           MOVGE    R0,#+0
     97          	}
   \   00000170   E930A0E3           MOV      R3,#+233
   \   00000174   C03F83E3           ORR      R3,R3,#0x300
   \   00000178   011083E0           ADD      R1,R3,R1
   \   0000017C   012052E2           SUBS     R2,R2,#+1
   \   00000180   E7FFFF1A           BNE      ??MyIDLECSM_onMessage_5
     98          	DrwImg((IMGHDR *)&img1,X,Y,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(1));
   \   00000184   0100A0E3           MOV      R0,#+1
   \   00000188   2E0100EF           SWI      +302
   \   0000018C   0060A0E1           MOV      R6,R0
   \   00000190   0000A0E3           MOV      R0,#+0
   \   00000194   2E0100EF           SWI      +302
   \   00000198   0030A0E1           MOV      R3,R0
   \   0000019C   7C009FE5           LDR      R0,??MyIDLECSM_onMessage_0+0xC  ;; img1
   \   000001A0   40002DE9           PUSH     {R6}
   \   000001A4   8420A0E3           MOV      R2,#+132
   \   000001A8   5110A0E3           MOV      R1,#+81
   \   000001AC   ........           BL       DrwImg
     99          	if (cop==0)
   \   000001B0   1904D4E5           LDRB     R0,[R4, #+1049]
   \   000001B4   04D08DE2           ADD      SP,SP,#+4
   \   000001B8   000050E3           CMP      R0,#+0
   \   000001BC   1200001A           BNE      ??MyIDLECSM_onMessage_4
    100          	  DrawString(ws1,0,100,131,131,11,0x20,GetPaletteAdrByColorIndex(0),GetPaletteAdrByColorIndex(1));
   \   000001C0   0100A0E3           MOV      R0,#+1
   \   000001C4   2E0100EF           SWI      +302
   \   000001C8   0060A0E1           MOV      R6,R0
   \   000001CC   0000A0E3           MOV      R0,#+0
   \   000001D0   2E0100EF           SWI      +302
   \   000001D4   40002DE9           PUSH     {R6}
   \   000001D8   01002DE9           PUSH     {R0}
   \   000001DC   8330A0E3           MOV      R3,#+131
   \   000001E0   6420A0E3           MOV      R2,#+100
   \   000001E4   0010A0E3           MOV      R1,#+0
   \   000001E8   2000A0E3           MOV      R0,#+32
   \   000001EC   01002DE9           PUSH     {R0}
   \   000001F0   0B00A0E3           MOV      R0,#+11
   \   000001F4   01002DE9           PUSH     {R0}
   \   000001F8   8300A0E3           MOV      R0,#+131
   \   000001FC   01002DE9           PUSH     {R0}
   \   00000200   140494E5           LDR      R0,[R4, #+1044]
   \   00000204   4C0100EF           SWI      +332
   \   00000208   14D08DE2           ADD      SP,SP,#+20
    101                }
    102              }
    103            }
    104            return(csm_result);
   \                     ??MyIDLECSM_onMessage_4:
   \   0000020C   0500A0E1           MOV      R0,R5
   \   00000210   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??MyIDLECSM_onMessage_0:
   \   00000214   ........           DC32     img1_bmp
   \   00000218   1F85EB51           DC32     0x51eb851f
   \   0000021C   93244992           DC32     0x92492493
   \   00000220   ........           DC32     img1
    105          }
    106          
    107          

   \                                 In segment CODE, align 4, keep-with-next
    108          int main(void)
    109          {
   \                     main:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
    110            hhh=0;
   \   00000004   84409FE5           LDR      R4,??main_0+0x4  ;; img1_bmp
   \   00000008   0000A0E3           MOV      R0,#+0
   \   0000000C   1804C4E5           STRB     R0,[R4, #+1048]
    111            LockSched();
   \   00000010   460100EF           SWI      +326
    112            CSM_RAM *icsm=FindCSMbyID(CSM_root()->idle_id);
   \   00000014   068100EF           SWI      +33030
   \   00000018   040090E5           LDR      R0,[R0, #+4]
   \   0000001C   FA6FA0E3           MOV      R6,#+1000
   \   00000020   080100EF           SWI      +264
   \   00000024   0050A0E1           MOV      R5,R0
    113            memcpy(&icsmd,icsm->constr,sizeof(icsmd));
   \   00000028   081095E5           LDR      R1,[R5, #+8]
   \   0000002C   2820A0E3           MOV      R2,#+40
   \   00000030   040086E0           ADD      R0,R6,R4
   \   00000034   1E0100EF           SWI      +286
    114            old_icsm_onMessage=icsmd.onMessage;
   \   00000038   040096E7           LDR      R0,[R6, +R4]
   \   0000003C   100484E5           STR      R0,[R4, #+1040]
    115            icsmd.onMessage=MyIDLECSM_onMessage;
   \   00000040   4C009FE5           LDR      R0,??main_0+0x8  ;; MyIDLECSM_onMessage
   \   00000044   040086E7           STR      R0,[R6, +R4]
    116            icsm->constr=&icsmd;
   \   00000048   040086E0           ADD      R0,R6,R4
   \   0000004C   080085E5           STR      R0,[R5, #+8]
    117            ws1=AllocWS(100);
   \   00000050   6400A0E3           MOV      R0,#+100
   \   00000054   250100EF           SWI      +293
    118            wsprintf(ws1,"%t","CPUMon by BoBa, Rst7");
   \   00000058   38209FE5           LDR      R2,??main_0+0xC  ;; `?<Constant "CPUMon by BoBa, Rst7">`
   \   0000005C   140484E5           STR      R0,[R4, #+1044]
   \   00000060   091F8FE2           ADR      R1,??main_0      ;; "%t"
   \   00000064   240100EF           SWI      +292
    119            GBS_StartTimerProc(&mytmr,UPDATE_TIME*10,TimerProc);
   \   00000068   ........           LDR      R2,??DataTable1  ;; TimerProc
   \   0000006C   3C10A0E3           MOV      R1,#+60
   \   00000070   A01E81E3           ORR      R1,R1,#0xA00
   \   00000074   9C0086E2           ADD      R0,R6,#+156
   \   00000078   040080E0           ADD      R0,R0,R4
   \   0000007C   4D0000EF           SWI      +77
    120            UnlockSched();
   \   00000080   470100EF           SWI      +327
    121            return 0;
   \   00000084   0000A0E3           MOV      R0,#+0
   \   00000088   7080BDE8           POP      {R4-R6,PC}       ;; return
   \                     ??main_0:
   \   0000008C   25740000           DC8      "%t",+0
   \   00000090   ........           DC32     img1_bmp
   \   00000094   ........           DC32     MyIDLECSM_onMessage
   \   00000098   ........           DC32     `?<Constant "CPUMon by BoBa, Rst7">`
    122          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     TimerProc

   \                                 In segment DATA_C, align 1, align-sorted
   \   00000000   257400             DC8 "%t"

   \                                 In segment DATA_C, align 4, align-sorted
   \                     `?<Constant "CPUMon by BoBa, Rst7">`:
   \   00000000   4350554D6F6E       DC8 "CPUMon by BoBa, Rst7"
   \              20627920426F
   \              42612C205273
   \              743700      
   \   00000015   000000             DC8 0, 0, 0

   Maximum stack usage in bytes:

     Function            CSTACK
     --------            ------
     DrwImg                 64
     MyIDLECSM_onMessage    36
     TimerProc               4
     main                   16


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     img1                              8
     img1_bmp                       1172
     DrwImg                           92
     TimerProc                        60
     MyIDLECSM_onMessage             548
     main                            156
     ??DataTable1                      4
     ?<Constant "%t">                  3
     ?<Constant "CPUMon by BoBa, Rst7">
                                      24
      Others                          28

 
   876 bytes in segment CODE
    35 bytes in segment DATA_C
 1 172 bytes in segment DATA_Z
    12 bytes in segment INITTAB
 
   860 bytes of CODE  memory (+ 28 bytes shared)
    35 bytes of CONST memory
 1 172 bytes of DATA  memory

Errors: none
Warnings: none
