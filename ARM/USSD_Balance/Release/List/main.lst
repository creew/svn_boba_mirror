##############################################################################
#                                                                            #
# IAR ARM ANSI C/C++ Compiler V4.40A/W32 EVALUATION    23/Dec/2006  11:14:02 #
# Copyright 1999-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Cpu mode        =  interwork                                            #
#    Endian          =  little                                               #
#    Stack alignment =  4                                                    #
#    Source file     =  D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\ma #
#                       in.c                                                 #
#    Command line    =  D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\ma #
#                       in.c -lC D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_B #
#                       alance\Release\List\ -la D:\MOBILE\ELFS\SVN_82_207_8 #
#                       9_182\ARM\USSD_Balance\Release\List\ -o              #
#                       D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\Re #
#                       lease\Obj\ -s9 --no_unroll --cpu_mode arm --endian   #
#                       little --cpu ARM7TDMI --stack_align 4 --interwork    #
#                       -e --fpu None -I D:\MOBILE\ELFS\IAR\Iar\ARM\INC\     #
#    List file       =  D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\Re #
#                       lease\List\main.lst                                  #
#    Object file     =  D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\Re #
#                       lease\Obj\main.r79                                   #
#                                                                            #
#                                                                            #
##############################################################################

D:\MOBILE\ELFS\SVN_82_207_89_182\ARM\USSD_Balance\main.c
      1          #include "..\inc\swilib.h"
      2          #include "..\inc\cfg_items.h"
      3          #include "conf_loader.h"
      4          
      5          extern char ussd_str[64];
      6          

   \                                 In segment CODE, align 4, keep-with-next
      7          void Killer(void){
   \                     Killer:
   \   00000000   00402DE9           PUSH     {LR}
      8            extern void *ELF_BEGIN;
      9            extern void kill_data(void *p, void (*func_p)(void *));
     10            kill_data(&ELF_BEGIN,(void (*)(void *))mfree_adr());
   \   00000004   158000EF           SWI      +32789
   \   00000008   0010A0E1           MOV      R1,R0
   \   0000000C   08009FE5           LDR      R0,??Killer_0    ;; ELF_BEGIN
   \   00000010   ........           _BLF     kill_data,??kill_data??rA
     11          //  ((void (*)(void *))(mfree_adr()))(&ELF_BEGIN);
     12          }
   \   00000014   0040BDE8           POP      {LR}
   \   00000018   1EFF2FE1           BX       LR               ;; return
   \                     ??Killer_0:
   \   0000001C   ........           DC32     ELF_BEGIN
     13          
     14          

   \                                 In segment CODE, align 4, keep-with-next
     15          void SendKeyPress(int key)
     16          {
   \                     SendKeyPress:
   \   00000000   30402DE9           PUSH     {R4,R5,LR}
   \   00000004   0040A0E1           MOV      R4,R0
     17            GBS_SendMessage(MMI_CEPID,KEY_DOWN,key);
   \   00000008   0950A0E3           MOV      R5,#+9
   \   0000000C   425C85E3           ORR      R5,R5,#0x4200
   \   00000010   0420A0E1           MOV      R2,R4
   \   00000014   9310A0E3           MOV      R1,#+147
   \   00000018   401F81E3           ORR      R1,R1,#0x100
   \   0000001C   0500A0E1           MOV      R0,R5
   \   00000020   000100EF           SWI      +256
     18            GBS_SendMessage(MMI_CEPID,KEY_UP,key);
   \   00000024   0420A0E1           MOV      R2,R4
   \   00000028   651FA0E3           MOV      R1,#+404
   \   0000002C   0500A0E1           MOV      R0,R5
   \   00000030   000100EF           SWI      +256
     19          };
   \   00000034   3040BDE8           POP      {R4,R5,LR}
   \   00000038   1EFF2FE1           BX       LR               ;; return
     20          
     21          //* 1 2 3 4 5 6
     22          //(6) 1 2 3 4 5 *
     23          //
     24          //
     25          //
     26          
     27          CSM_RAM *under_idle;
     28          CSM_RAM *idlecsm;
     29          

   \                                 In segment CODE, align 4, keep-with-next
     30          void swap_csms(CSM_RAM*a,CSM_RAM*b)
     31          {
   \                     swap_csms:
   \   00000000   10002DE9           PUSH     {R4}
     32            if(a==b) return;
   \   00000004   010050E1           CMP      R0,R1
   \   00000008   0700000A           BEQ      ??swap_csms_0
     33            
     34            void * ap,*an,*bp,*bn;
     35            ap=a->prev;
   \   0000000C   042090E5           LDR      R2,[R0, #+4]
     36            an=a->next;
   \   00000010   003090E5           LDR      R3,[R0, #+0]
     37            bp=b->prev;
     38            bn=b->next;
   \   00000014   00C091E5           LDR      R12,[R1, #+0]
     39            a->prev=bp;
   \   00000018   044091E5           LDR      R4,[R1, #+4]
   \   0000001C   044080E5           STR      R4,[R0, #+4]
     40            a->next=bn;
   \   00000020   00C080E5           STR      R12,[R0, #+0]
     41            b->prev=ap;
   \   00000024   042081E5           STR      R2,[R1, #+4]
     42            b->next=an;
   \   00000028   003081E5           STR      R3,[R1, #+0]
     43          };
   \                     ??swap_csms_0:
   \   0000002C   1000BDE8           POP      {R4}
   \   00000030   1EFF2FE1           BX       LR               ;; return
     44          

   \                                 In segment CODE, align 4, keep-with-next
     45          CSM_RAM* TopCsmId()
     46          {
     47          CSM_RAM* icsm=under_idle;  
   \                     TopCsmId:
   \   00000000   ........           LDR      R0,??DataTable1  ;; under_idle
   \   00000004   000090E5           LDR      R0,[R0, #+0]
   \   00000008   001090E5           LDR      R1,[R0, #+0]
   \   0000000C   000051E3           CMP      R1,#+0
   \   00000010   1EFF2F01           BXEQ     LR
     48          while(icsm->next!=0) icsm=icsm->next;
   \                     ??TopCsmId_0:
   \   00000014   000090E5           LDR      R0,[R0, #+0]
   \   00000018   001090E5           LDR      R1,[R0, #+0]
   \   0000001C   000051E3           CMP      R1,#+0
   \   00000020   FBFFFF1A           BNE      ??TopCsmId_0
     49          return icsm;
   \   00000024   1EFF2FE1           BX       LR               ;; return
     50          };
     51          

   \                                 In segment CODE, align 4, keep-with-next
     52          void SwitchToIdle()
     53          {
   \                     SwitchToIdle:
   \   00000000   00402DE9           PUSH     {LR}
     54          /*  GBS_SendMessage(MMI_CEPID,KEY_DOWN,RED_BUTTON);
     55            GBS_SendMessage(MMI_CEPID,LONG_PRESS,RED_BUTTON);
     56            GBS_SendMessage(MMI_CEPID,KEY_UP,RED_BUTTON);*/ 
     57          swap_csms(TopCsmId(),idlecsm);  
   \   00000004   ........           BL       TopCsmId
   \   00000008   0C109FE5           LDR      R1,??SwitchToIdle_0  ;; under_idle + 4
   \   0000000C   001091E5           LDR      R1,[R1, #+0]
   \   00000010   ........           BL       swap_csms
     58          };
   \   00000014   0040BDE8           POP      {LR}
   \   00000018   1EFF2FE1           BX       LR               ;; return
   \                     ??SwitchToIdle_0:
   \   0000001C   ........           DC32     under_idle + 4
     59          

   \                                 In segment CODE, align 4, keep-with-next
     60          void SwitchFromIdle()
     61          {
     62          //swap_csms(TopCsmId(),idlecsm);
     63          };
   \                     SwitchFromIdle:
   \   00000000   1EFF2FE1           BX       LR               ;; return

   \                                 In segment DATA_Z, align 4, align-sorted
   \                     under_idle:
   \   00000000                      DS8 4
   \                     idlecsm:
   \   00000004                      DS8 4
     64          
     65          GBSTMR timer;
   \                     timer:
   \   00000008                      DS8 16
     66          

   \                                 In segment CODE, align 4, keep-with-next
     67          void timer_proc(void){
   \                     timer_proc:
   \   00000000   10402DE9           PUSH     {R4,LR}
     68            
     69           SendKeyPress('*');
   \   00000004   2A00A0E3           MOV      R0,#+42
   \   00000008   ........           BL       SendKeyPress
     70           for(char *s=ussd_str;*s!=0;s++)
   \   0000000C   38409FE5           LDR      R4,??timer_proc_0  ;; ussd_str
   \   00000010   010000EA           B        ??timer_proc_1
     71             SendKeyPress(*s);
   \                     ??timer_proc_2:
   \   00000014   ........           LDRB     R0,[R4], #+1
   \   00000018   ........           BL       SendKeyPress
   \                     ??timer_proc_1:
   \   0000001C   0000D4E5           LDRB     R0,[R4, #+0]
   \   00000020   000050E3           CMP      R0,#+0
   \   00000024   FAFFFF1A           BNE      ??timer_proc_2
     72           SendKeyPress(GREEN_BUTTON); 
   \   00000028   0B00A0E3           MOV      R0,#+11
   \   0000002C   ........           BL       SendKeyPress
     73           
     74           GBS_StartTimerProc(&timer,(262/10)*10, SwitchFromIdle);   
   \   00000030   18209FE5           LDR      R2,??timer_proc_0+0x4  ;; SwitchFromIdle
   \   00000034   411FA0E3           MOV      R1,#+260
   \   00000038   14009FE5           LDR      R0,??timer_proc_0+0x8  ;; under_idle + 8
   \   0000003C   4D0000EF           SWI      +77
     75           
     76           Killer();
   \   00000040   ........           BL       Killer
     77          }
   \   00000044   1040BDE8           POP      {R4,LR}
   \   00000048   1EFF2FE1           BX       LR               ;; return
   \                     ??timer_proc_0:
   \   0000004C   ........           DC32     ussd_str
   \   00000050   ........           DC32     SwitchFromIdle
   \   00000054   ........           DC32     under_idle + 8
     78          
     79          

   \                                 In segment CODE, align 4, keep-with-next
     80          int main(void)
     81          {     
   \                     main:
   \   00000000   10402DE9           PUSH     {R4,LR}
     82            InitConfig();
   \   00000004   ........           _BLF     InitConfig,??InitConfig??rA
     83          
     84            idlecsm=FindCSMbyID(CSM_root()->idle_id);  
   \   00000008   068100EF           SWI      +33030
   \   0000000C   ........           LDR      R4,??DataTable1  ;; under_idle
   \   00000010   040090E5           LDR      R0,[R0, #+4]
   \   00000014   080100EF           SWI      +264
   \   00000018   040084E5           STR      R0,[R4, #+4]
     85            under_idle=(FindCSMbyID(CSM_root()->idle_id))->prev; 
   \   0000001C   068100EF           SWI      +33030
   \   00000020   040090E5           LDR      R0,[R0, #+4]
   \   00000024   080100EF           SWI      +264
   \   00000028   040090E5           LDR      R0,[R0, #+4]
   \   0000002C   000084E5           STR      R0,[R4, #+0]
     86            
     87            SwitchToIdle();
   \   00000030   ........           BL       SwitchToIdle
     88            
     89            GBS_StartTimerProc(&timer,(262/10)*10,timer_proc);   
   \   00000034   14209FE5           LDR      R2,??main_0      ;; timer_proc
   \   00000038   411FA0E3           MOV      R1,#+260
   \   0000003C   080084E2           ADD      R0,R4,#+8
   \   00000040   4D0000EF           SWI      +77
     90            
     91            return 0;
   \   00000044   0000A0E3           MOV      R0,#+0
   \   00000048   1040BDE8           POP      {R4,LR}
   \   0000004C   1EFF2FE1           BX       LR               ;; return
   \                     ??main_0:
   \   00000050   ........           DC32     timer_proc
     92          }

   \                                 In segment CODE, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   ........           DC32     under_idle

   Maximum stack usage in bytes:

     Function       CSTACK
     --------       ------
     Killer             4
     SendKeyPress      12
     SwitchFromIdle     0
     SwitchToIdle       4
     TopCsmId           0
     main               8
     swap_csms          4
     timer_proc         8


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     Killer           32
     SendKeyPress     60
     swap_csms        52
     TopCsmId         40
     SwitchToIdle     32
     SwitchFromIdle    4
     under_idle       24
     timer_proc       88
     main             84
     ??DataTable1      4
      Others          68

 
 452 bytes in segment CODE
  24 bytes in segment DATA_Z
  12 bytes in segment INITTAB
 
 396 bytes of CODE memory (+ 68 bytes shared)
  24 bytes of DATA memory

Errors: none
Warnings: none
