//////////////////////////////////////////////////////////////////////////////
//                                                                           /
// IAR ARM ANSI C/C++ Compiler V4.40A/W32 EVALUATION   22/Aug/2006  13:39:33 /
// Copyright 1999-2005 IAR Systems. All rights reserved.                     /
//                                                                           /
//    Cpu mode        =  interwork                                           /
//    Endian          =  little                                              /
//    Stack alignment =  4                                                   /
//    Source file     =  E:\ARM\elfloader\ELFLoader\elfloader.cpp            /
//    Command line    =  E:\ARM\elfloader\ELFLoader\elfloader.cpp -D NDEBUG  /
//                       -lC E:\ARM\elfloader\ELFLoader\Release\List\ -lA    /
//                       E:\ARM\elfloader\ELFLoader\Release\List\ -o         /
//                       E:\ARM\elfloader\ELFLoader\Release\Obj\ -s9         /
//                       --no_unroll --cpu_mode thumb --endian little --cpu  /
//                       ARM926EJ-S --stack_align 4 --interwork -e --fpu     /
//                       None -I D:\IARARM\ARM\INC\                          /
//    List file       =  E:\ARM\elfloader\ELFLoader\Release\List\elfloader.s /
//                       79                                                  /
//                                                                           /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

        NAME elfloader

        RTMODEL "StackAlign4", "USED"
        RTMODEL "__cpu_mode", "__pcs__interwork"
        RTMODEL "__data_model", "absolute"
        RTMODEL "__endian", "little"
        RTMODEL "__rt_version", "6"

        RSEG CSTACK:DATA:NOROOT(2)

        MULTWEAK ??CreateHELPER_PROC??rA
        MULTWEAK ??DoUnknownFileType??rT
        MULTWEAK ??ESI??rT
        MULTWEAK ??ExecuteIMB??rT
        MULTWEAK ??LoadDaemons??rT
        MULTWEAK ??MyIDLECSMonClose??rT
        MULTWEAK ??MyIDLECSMonCreate??rT
        MULTWEAK ??MyShowMSG??rA
        MULTWEAK ??elfload??rA
        MULTWEAK ??elfloader_onload??rA
        MULTWEAK ??toupper??rA
        MULTWEAK ??zeromem_a??rT
        PUBLIC CreateHELPER_PROC
        FUNCTION CreateHELPER_PROC,0203H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC DoUnknownFileType
        FUNCTION DoUnknownFileType,0603H
        LOCFRAME CSTACK, 428, STACK
        PUBLIC ESI
        FUNCTION ESI,0203H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC LoadDaemons
        FUNCTION LoadDaemons,0603H
        LOCFRAME CSTACK, 1104, STACK
        PUBLIC MyIDLECSMonClose
        FUNCTION MyIDLECSMonClose,080603H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC MyIDLECSMonCreate
        FUNCTION MyIDLECSMonCreate,080603H
        LOCFRAME CSTACK, 12, STACK
        PUBLIC MyShowMSG
        FUNCTION MyShowMSG,080603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC REDRAW_impl
        FUNCTION REDRAW_impl,0603H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC SUBPROC_impl
        FUNCTION SUBPROC_impl,0603H
        LOCFRAME CSTACK, 8, STACK
        PUBLIC elfload
        FUNCTION elfload,0203H
        LOCFRAME CSTACK, 536, STACK
        PUBLIC elfloader_onload
        FUNCTION elfloader_onload,0603H
        LOCFRAME CSTACK, 132, STACK
        PUBLIC proc_HELPER
        FUNCTION proc_HELPER,0603H
        LOCFRAME CSTACK, 24, STACK
        PUBLIC toupper
        FUNCTION toupper,0203H
        LOCFRAME CSTACK, 4, STACK
        PUBLIC zeromem_a
        FUNCTION zeromem_a,0203H
        LOCFRAME CSTACK, 4, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 HUGEDATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, CPSR:32, R13:32
        CFI Resource R14:32, SPSR:32
        CFI VirtualResource ?RET:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 4
        CFI DataAlign 4
        CFI ReturnAddress ?RET CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI CPSR SameValue
        CFI R14 Undefined
        CFI SPSR SameValue
        CFI ?RET R14
        CFI EndCommon cfiCommon1
        
ExecuteIMB          SYMBOL "ExecuteIMB"
CreateHELPER_PROC   SYMBOL "CreateHELPER_PROC"
??CreateHELPER_PROC??rA SYMBOL "??rA", CreateHELPER_PROC
DoUnknownFileType   SYMBOL "DoUnknownFileType"
??DoUnknownFileType??rT SYMBOL "??rT", DoUnknownFileType
ESI                 SYMBOL "ESI"
??ESI??rT           SYMBOL "??rT", ESI
??ExecuteIMB??rT    SYMBOL "??rT", ExecuteIMB
LoadDaemons         SYMBOL "LoadDaemons"
??LoadDaemons??rT   SYMBOL "??rT", LoadDaemons
MyIDLECSMonClose    SYMBOL "MyIDLECSMonClose"
??MyIDLECSMonClose??rT SYMBOL "??rT", MyIDLECSMonClose
MyIDLECSMonCreate   SYMBOL "MyIDLECSMonCreate"
??MyIDLECSMonCreate??rT SYMBOL "??rT", MyIDLECSMonCreate
MyShowMSG           SYMBOL "MyShowMSG"
??MyShowMSG??rA     SYMBOL "??rA", MyShowMSG
elfload             SYMBOL "elfload"
??elfload??rA       SYMBOL "??rA", elfload
elfloader_onload    SYMBOL "elfloader_onload"
??elfloader_onload??rA SYMBOL "??rA", elfloader_onload
toupper             SYMBOL "toupper"
??toupper??rA       SYMBOL "??rA", toupper
zeromem_a           SYMBOL "zeromem_a"
??zeromem_a??rT     SYMBOL "??rT", zeromem_a

        EXTERN ExecuteIMB
        FUNCTION ExecuteIMB,0202H
        EXTERN OldOnClose
        EXTERN OldOnCreate
        EXTERN OldShowMsg


        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI NoFunction
        THUMB
??zeromem_a??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock0
        REQUIRE zeromem_a
// E:\ARM\elfloader\ELFLoader\elfloader.cpp
//    1 //#define wintel		//ÍÓÏÔÂÎËÏ ÔÓ‰ ‚ËÌ‰Û
//    2 
//    3 #define MAX_PHNUM	10	//Ï‡ÍÒËÏ‡Î¸ÌÓÂ ÍÓÎË˜ÂÒÚ‚Ó ÔÓ„‡ÏÌ˚ı ÒÂ„ÏÂÌÚÓ‚
//    4 
//    5 #ifdef wintel
//    6 #include "stdlib.h"
//    7 #include "stdio.h"
//    8 #include "iostream.h"
//    9 #define mfree free
//   10 #endif
//   11 
//   12 #ifndef winntel
//   13 #include "E:\ARM\swilib.h"
//   14 #endif
//   15 
//   16 typedef unsigned long  Elf32_Addr;	//Unsigned program address 4
//   17 typedef unsigned short Elf32_Half;	//Unsigned medium integer  2
//   18 typedef unsigned long  Elf32_Off; 	//Unsigned file offset     4
//   19 typedef          long  Elf32_Sword; 	//Signed large integer     4
//   20 typedef unsigned long  Elf32_Word; 	//Unsigned large integer   4
//   21 
//   22 //ELF Header
//   23 //e_ident[] Identification Indexes
//   24 #define EI_MAG0    0  //File identification
//   25 #define EI_MAG1    1  //File identification
//   26 #define EI_MAG2    2  //File identification
//   27 #define EI_MAG3    3  //File identification
//   28 #define EI_CLASS   4  //File class
//   29 #define EI_DATA    5  //Data encoding
//   30 #define EI_VERSION 6  //File version
//   31 #define EI_PAD     7  //Start of padding bytes
//   32 #define EI_NIDENT  16 //Size of e_ident[]
//   33 
//   34 typedef struct{
//   35   unsigned char e_ident[EI_NIDENT]; //The initial bytes mark the file as an object file and provide machine-independent data with which to decode and interpret the fileís contents.
//   36   Elf32_Half e_type;      //This member identifies the object file type.
//   37   Elf32_Half e_machine;   //This memberís value specifies the required architecture for an individual file.
//   38   Elf32_Word e_version;   //This member identifies the object file version.
//   39   Elf32_Addr e_entry;     //This member gives the virtual address to which the system first transfers control, thus starting the process. If the file has no associated entry point, this member holds zero.
//   40   Elf32_Off  e_phoff;     //This member holds the program header tableís file offset in bytes. If the file has no program header table, this member holds zero.
//   41   Elf32_Off  e_shoff;     //This member holds the section header tableís file offset in bytes. If the file has no section header table, this member holds zero.
//   42   Elf32_Word e_flags;     //This member holds processor-specific flags associated with the file. Flag names take the form EF_machine_flag.
//   43   Elf32_Half e_ehsize;    //This member holds the ELF headerís size in bytes.
//   44   Elf32_Half e_phentsize; //This member holds the size in bytes of one entry in the fileís program header table; all entries are the same size.
//   45   Elf32_Half e_phnum;     //This member holds the number of entries in the program header table. Thus the product of e_phentsize and e_phnum gives the tableís size in bytes. If a file has no program header table, e_phnum holds the value zero.
//   46   Elf32_Half e_shentsize; //This member holds a section headerís size in bytes. A section header is one entry in the section header table; all entries are the same size.
//   47   Elf32_Half e_shnum;     //shnumóThis member holds the number of entries in the section header table. Thus the product of e_shentsize and e_shnum gives the section header tableís size in bytes. If a file has no section header table, e_shnum holds the value zero.
//   48   Elf32_Half e_shstrndx;  //This member holds the section header table index of the entry associated with the section name string table. If the file has no section name string table, this member holds the value SHN_UNDEF.
//   49 } Elf32_Ehdr;
//   50 
//   51 //E_typeóThis member identifies the object file type.
//   52 #define ET_NONE   0        //No file type
//   53 #define ET_REL    1        //Re-locatable file
//   54 #define ET_EXEC   2        //Executable file
//   55 #define ET_DYN    3        //Shared object file
//   56 #define ET_CORE   4        //Core file
//   57 #define ET_LOPROC 0xFF00   //Processor-specific
//   58 #define ET_HIPROC 0xFFFF   //Processor-specific
//   59 
//   60 //E_machineóThis memberís value specifies the required architecture for an individual file.
//   61 #define EM_NONE        0  //No machine
//   62 #define EM_M32         1  //AT&T WE 32100
//   63 #define EM_SPARC       2  //SPARC
//   64 #define EM_386         3  //Intel Architecture
//   65 #define EM_68K         4  //Motorola 68000
//   66 #define EM_88K         5  //Motorola 88000
//   67 #define EM_860         7  //Intel 80860
//   68 #define EM_MIPS        8  //MIPS RS3000 Big-Endian
//   69 #define EM_MIPS_RS4_BE 10 //MIPS RS4000 Big-Endian
//   70 #define EM_ARM         40 //ARM/Thumb Architecture
//   71 
//   72 //E_versionóThis member identifies the object file version.
//   73 #define EV_NONE    0 //Invalid version
//   74 #define EV_CURRENT 1 //Current version
//   75 
//   76 //EI_MAG0 0 to EI_MAG3óA fileís first 4 bytes hold a magic number, identifying the file as an ELF object file. Name Value Meaning
//   77 #define ELFMAG0 0x7f //e_ident[EI_MAG0]
//   78 #define ELFMAG1 'E' //e_ident[EI_MAG1]
//   79 #define ELFMAG2 'L' //e_ident[EI_MAG2]
//   80 #define ELFMAG3 'F' //e_ident[EI_MAG3]
//   81 
//   82 //EI_CLASSóThe next byte, e_ident[EI_CLASS], identifies the fileís class, or capacity. Name Value Meaning
//   83 #define ELFCLASSNONE 0 //Invalid class
//   84 #define ELFCLASS32   1 //32-bit objects
//   85 #define ELFCLASS64   2 //64-bit objects
//   86 
//   87 //EI_DATAóByte e_ident[EI_DATA]specifies the data encoding of all data1 in the object file. The following encodings are currently defined. Name Value Meaning
//   88 #define ELFDATANONE 0 //Invalid data encoding
//   89 #define ELFDATA2LSB 1 //See Data encodings ELFDATA2LSB, below
//   90 #define ELFDATA2MSB 2 //See Data encodings ELFDATA2MSB, below
//   91 
//   92 //Sections
//   93 //Section Header
//   94 typedef struct{
//   95   Elf32_Word sh_name;      //This member specifies the name of the section. Its value is an index into the section header string table section [see section 3.4, String Table below], giving the location of a null-terminated string.
//   96   Elf32_Word sh_type;      //typeóThis member categorizes the sectionís contents and semantics. Section types and their descriptions appear in Figure 3-9 below.
//   97   Elf32_Word sh_flags;     //Sections support 1-bit flags that describe miscellaneous attributes. Flag definitions appear in Figure 3-11, below.
//   98   Elf32_Addr sh_addr;      //If the section will appear in the memory image of a process, this member gives the address at which the sectionís first byte should reside. Otherwise, the member contains 0.
//   99   Elf32_Off  sh_offset;    //This memberís value gives the byte offset from the beginning of the file to the first byte in the section. One section type, SHT_NOBITS described in Figure 3-9 below, occupies no space in the file, and its sh_offset member locates the conceptual placement in the file.
//  100   Elf32_Word sh_size;      //This member gives the sectionís size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS may have a non-zero size, but it occupies no space in the file.
//  101   Elf32_Word sh_link;      //This member holds a section header table index link, whose interpretation depends on the section type. Figure 3-12 below describes the values.
//  102   Elf32_Word sh_info;      //This member holds extra information, whose interpretation depends on the section type. Figure 3-12 below describes the values.
//  103   Elf32_Word sh_addralign; //Some sections have address alignment constraints. For example, if a section holds a doubleword, the system must ensure double-word alignment for the entire section. That is, the value of sh_addr must be congruent to 0, modulo the value of sh_addralign. Currently, only 0 and positive integral powers of two are allowed. Values 0 and 1 mean the section has no alignment constraints.
//  104   Elf32_Word sh_entsize;   //Some sections hold a table of fixed-size entries, such as a symbol table. For such a section, this member gives the size in bytes of each entry. The member contains 0 if the section does not hold a table of fixedsize entries. A section headerís sh_type member specifies the sectionís semantics.
//  105 } Elf32_Shdr;
//  106 
//  107 //Special Section Indexes
//  108 #define SHN_UNDEF     0     //This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference. For example, a symbol ìdefinedî relative to section number SHN_UNDEF is an undefined symbol.
//  109 #define SHN_LORESERVE 0xff00 //This value specifies the lower bound of the range of reserved indexes.
//  110 #define SHN_LOPROC    0xff00 //Values in this range are reserved for processor-specific semantics.
//  111 #define SHN_HIPROC    0xff1f //Values in this range are reserved for processor-specific semantics.
//  112 #define SHN_ABS       0xfff1 //This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have absolute values and are not affected by relocation.
//  113 #define SHN_COMMON    0xfff2 //Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.
//  114 #define SHN_HIRESERVE 0xffff //This value specifies the upper bound of the range of reserved indexes. The system reserves indexes between SHN_LORESERVE and SHN_HIRESERVE, inclusive; the values do not refer to the section header table. That is, the section header table does not contain entries for the reserved indexes.
//  115 
//  116 //sh_type
//  117 #define SHT_NULL     0  //This value marks a section header that does not have an associated section. Other members of the section header have undefined values
//  118 #define SHT_PROGBITS 1  //The section holds information defined by the program, whose format and meaning are determined solely by the program.
//  119 #define SHT_SYMTAB   2  //The section holds a symbol table.
//  120 #define SHT_STRTAB   3  //The section holds a string table.
//  121 #define SHT_RELA     4  //The section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
//  122 #define SHT_HASH     5  //The section holds a symbol hash table.
//  123 #define SHT_DYNAMIC  6  //The section holds information for dynamic linking.
//  124 #define SHT_NOTE     7  //This section holds information that marks the file in some way.
//  125 #define SHT_NOBITS   8  //A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.
//  126 #define SHT_REL      9  //The section holds relocation entries without explicit addends, such as type Elf32_Rel for the 32-bit class of object files. An object file may have multiple relocation sections. See Relocation below for details.
//  127 #define SHT_SHLIB    10 //This section type is reserved but has unspecified semantics.
//  128 #define SHT_DYNSYM   11 //The section holds a symbol table.
//  129 #define SHT_LOPROC   0x70000000
//  130 #define SHT_HIPROC   0x7fffffff //Values in this inclusive range are reserved for processor-specific semantics.
//  131 #define SHT_LOUSER   0x80000000
//  132 #define SHT_HIUSER   0xffffffff //Values in this inclusive range are reserved for application programs. Types between SHT_LOUSER and SHT_HIUSER may be used by an application,without conflicting with current or future system-defined section types.
//  133 
//  134 //Section Attribute Flags, sh_flags
//  135 #define SHF_WRITE     1          //The section contains data that should be writable during process execution
//  136 #define SHF_ALLOC     2          //The section occupies memory during process execution. Some control sections do not reside in the memory image of an object file; this attribute is off for those sections
//  137 #define SHF_EXECINSTR 4          //The section contains executable machine instructions.
//  138 #define SHF_MASKPROC  0xf0000000 //Bits in this mask are reserved for processor-specific semantics.
//  139 
//  140 //Program
//  141 //Program Header
//  142 typedef struct{
//  143   Elf32_Word p_type;   //This member tells what kind of segment this array element describes or how to interpret the array element's information. Type values and their meanings are given in Figure 3-21, below.
//  144   Elf32_Off p_offset;  //This member gives the offset from the start of the file at which the first byte of the segment resides.
//  145   Elf32_Addr p_vaddr;  //This member gives the virtual address at which the first byte of the segment resides in memory.
//  146   Elf32_Addr p_paddr;  //On systems for which physical addressing is relevant, this member is reserved for the segment's physical address. This member requires operating system specific information.
//  147   Elf32_Word p_filesz; //This member gives the number of bytes in the file image of the segment; it may be zero.
//  148   Elf32_Word p_memsz;  //This member gives the number of bytes in the memory image of the segment; it may be zero.
//  149   Elf32_Word p_flags;  //This member gives flags relevant to the segment. Defined flag values are given in Figure 3-22, below.
//  150   Elf32_Word p_align;  //Loadable process segments must have congruent values for p_vaddr and p_offset, modulo the page size. This member gives the value to which the segments are aligned in memory and in the file. Values 0 and 1 mean that no alignment is required. Otherwise, p_align should be a positive, integral power of 2, and p_vaddr should equal p_offset, modulo p_align.
//  151 } Elf32_Phdr;
//  152 
//  153 //Defined program header flags
//  154 #define PF_X 1 //The segment may be executed.
//  155 #define PF_W 2 //The segment may be written to.
//  156 #define PF_R 4 //The segment may be read.
//  157 #define PF_MASKPROC 0xf0000000 //Reserved for processor-specific purposes (see 4.6, Program headers).
//  158 
//  159 //Segment Types, p_type
//  160 #define PT_NULL    0 //The array element is unused; other members' values are undefined. This type lets the program header table have ignored entries.
//  161 #define PT_LOAD    1 //The array element specifies a loadable segment, described by p_filesz and p_memsz (for additional explanation, see PT_LOAD below).
//  162 #define PT_DYNAMIC 2 //The array element specifies dynamic linking information. See subsection 4.7.
//  163 #define PT_INTERP  3 //The array element specifies the location and size of a null-terminated path name to invoke as an interpreter.
//  164 #define PT_NOTE    4 //The array element specifies the location and size of auxiliary information.
//  165 #define PT_SHLIB   5 //This segment type is reserved but has unspecified semantics.
//  166 #define PT_PHDR    6 //The array element, if present, specifies the location and size of the program header table itself (for additional explanation, see PT_ PHDR below).
//  167 #define PT_LOPROC  0x70000000 //Values in this inclusive range are reserved for processor-specific semantics.
//  168 #define PT_HIPROC  0x7fffffff
//  169 
//  170 //The dynamic section
//  171 typedef struct{
//  172   Elf32_Sword d_tag;
//  173   Elf32_Word d_val;
//  174 } Elf32_Dyn;
//  175 
//  176 //Dynamic section tags
//  177 #define DT_NULL     0  //Ignored. This entry marks the end of the dynamic array. mandatory
//  178 #define DT_NEEDED   1  //Index in the string table of the name of a needed library. multiple
//  179 #define DT_PLTRELSZ 2  //These entries are unused by versions 1-2 of the ARM EABI. unused
//  180 #define DT_PLTGOT   3
//  181 #define DT_HASH     4  //The offset of the hash table section in the dynamic segment. mandatory
//  182 #define DT_STRTAB   5  //The offset of the string table section in the dynamic segment. mandatory
//  183 #define DT_SYMTAB   6  //The offset of the symbol table section in the dynamic segment. mandatory
//  184 #define DT_RELA     7  //The offset in the dynamic segment of an SHT_RELA relocation section, Its byte size, and the byte size of an ARM RELA-type relocation entry. optional
//  185 #define DT_RELASZ   8
//  186 #define DT_RELAENT  9
//  187 #define DT_STRSZ    10 //The byte size of the string table section. mandatory
//  188 #define DT_SYMENT   11 //The byte size of an ARM symbol table entryó16. mandatory
//  189 #define DT_INIT     12 //These entries are unused by versions 1-2 of the ARM EABI. unused
//  190 #define DT_FINI     13
//  191 #define DT_SONAME   14 //The Index in the string table of the name of this shared object. mandatory
//  192 #define DT_RPATH    15 //Unused by the ARM EABI. unused
//  193 #define DT_SYMBOLIC 16
//  194 #define DT_REL      17 //The offset in the dynamic segment of an SHT_REL relocation section, Its byte size, and the byte size of an ARM REL-type relocation entry optional
//  195 #define DT_RELSZ    18
//  196 #define DT_RELENT   19
//  197 #define DT_PLTREL   20 //These entries are unused by versions 1-2 of the ARM EABI. unused
//  198 #define DT_DEBUG    21
//  199 #define DT_TEXTREL  22
//  200 #define DT_JMPREL   23
//  201 #define DT_BIND_NOW 24
//  202 #define DT_LOPROC   0x70000000 //Values in this range are reserved to the ARM EABI. unused
//  203 #define DT_HIPROC   0x7fffffff
//  204 
//  205 //Relocation Entries
//  206 typedef struct{
//  207   Elf32_Addr r_offset;
//  208   Elf32_Word r_info;
//  209 } Elf32_Rel;
//  210 
//  211 #define ELF32_R_SYM(i) ((i)>>8)
//  212 #define ELF32_R_TYPE(i) ((unsigned char)(i))
//  213 #define ELF32_R_INFO(s,t) (((s)<<8)+(unsigned char)(t))
//  214 
//  215 //ARM relocation types
//  216 #define R_ARM_NONE            0   //Any No relocation. Encodes dependencies between sections.
//  217 #define R_ARM_PC24            1   //ARM B/BL S ñ P + A
//  218 #define R_ARM_ABS32           2   //32-bit word S + A
//  219 #define R_ARM_REL32           3   //32-bit word S ñ P + A
//  220 #define R_ARM_PC13            4   //ARM LDR r, [pc,Ö] S ñ P + A
//  221 #define R_ARM_ABS16           5   //16-bit half-word S + A
//  222 #define R_ARM_ABS12           6   //ARM LDR/STR S + A
//  223 #define R_ARM_THM_ABS5        7   //Thumb LDR/STR S + A
//  224 #define R_ARM_ABS8            8   //8-bit byte S + A
//  225 #define R_ARM_SBREL32         9   //32-bit word S ñ B + A
//  226 #define R_ARM_THM_PC22        10  //Thumb BL pair S ñ P+ A
//  227 #define R_ARM_THM_PC8         11  //Thumb LDR r, [pc,Ö] S ñ P + A
//  228 #define R_ARM_AMP_VCALL9      12  //AMP VCALL ObsoleteóSA-1500 only.
//  229 #define R_ARM_SWI24           13  //ARM SWI S + A
//  230 #define R_ARM_THM_SWI8        14  //Thumb SWI S + A
//  231 #define R_ARM_XPC25           15  //ARM BLX S ñ P+ A
//  232 #define R_ARM_THM_XPC22       16  //Thumb BLX pair S ñ P+ A
//  233 #define R_ARM_COPY            20  //32 bit word Copy symbol at dynamic link time.
//  234 #define R_ARM_GLOB_DAT        21  //32 bit word Create GOT entry.
//  235 #define R_ARM_JUMP_SLOT       22  //32 bit word Create PLT entry.
//  236 #define R_ARM_RELATIVE        23  //32 bit word Adjust by program base.
//  237 #define R_ARM_GOTOFF          24  //32 bit word Offset relative to start of GOT.
//  238 #define R_ARM_GOTPC           25  //32 bit word Insert address of GOT.
//  239 #define R_ARM_GOT32           26  //32 bit word Entry in GOT.
//  240 #define R_ARM_PLT32           27  //ARM BL Entry in PLT.
//  241 #define R_ARM_ALU_PCREL_7_0   32  //ARM ADD/SUB (S ñ P + A) & 0x000000FF
//  242 #define R_ARM_ALU_PCREL_15_8  33  //ARM ADD/SUB (S ñ P + A) & 0x0000FF00
//  243 #define R_ARM_ALU_PCREL_23_15 34  //ARM ADD/SUB (S ñ P + A) & 0x00FF0000
//  244 #define R_ARM_LDR_SBREL_11_0  35  //ARM LDR/STR (S ñ B + A) & 0x00000FFF
//  245 #define R_ARM_ALU_SBREL_19_12 36  //ARM ADD/SUB (S ñ B + A) & 0x000FF000
//  246 #define R_ARM_ALU_SBREL_27_20 37  //ARM ADD/SUB (S ñ B + A) & 0x0FF00000
//  247 #define R_ARM_GNU_VTENTRY     100 //32 bit word Record C++ vtable entry.
//  248 #define R_ARM_GNU_VTINHERIT   101 //32 bit word Record C++ member usage.
//  249 #define R_ARM_THM_PC11        102 //Thumb B S ñ P + A
//  250 #define R_ARM_THM_PC9         103 //Thumb B<cond> S ñ P + A
//  251 #define R_ARM_RXPC25          249 //ARM BLX (?S ñ ?P) + A For calls between program segments.
//  252 #define R_ARM_RSBREL32        250 //Word (?S ñ ?SB) + A For an offset from SB, the static base.
//  253 #define R_ARM_THM_RPC22       251 //Thumb BL/BLX pair (?S ñ ?P) + A For calls between program segments.
//  254 #define R_ARM_RREL32          252 //Word (?S ñ ?P) + A For on offset between two segments.
//  255 #define R_ARM_RABS32          253 //Word ?S + A For the address of a location in the target segment.
//  256 #define R_ARM_RPC24           254 //ARM B/BL (?S ñ ?P) + A For calls between program segments.
//  257 #define R_ARM_RBASE           255 //None NoneóIdentifies the segment being relocated by the following relocation directives.
//  258 
//  259 typedef long TElfEntry(char *, void *,void *,void *);
//  260 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock1 Using cfiCommon1
        CFI Function zeromem_a
        ARM
//  261 __arm zeromem_a(void *d, int l){zeromem(d,l);}
zeromem_a:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        SWI      +285
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock2 Using cfiCommon1
        CFI NoFunction
        ARM
??elfload??rA:
        ADD      R12,PC,#+1
        BX       R12
        CFI EndBlock cfiBlock2
        REQUIRE elfload
//  262 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock3 Using cfiCommon0
        CFI Function elfload
        THUMB
//  263 long elfload(char *filename, void *param1, void *param2, void *param3){
elfload:
        PUSH     {R0-R7,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R7 Frame(CFA, -8)
        CFI R6 Frame(CFA, -12)
        CFI R5 Frame(CFA, -16)
        CFI R4 Frame(CFA, -20)
        CFI CFA R13+36
        SUB      SP,SP,#+496
        CFI CFA R13+532
//  264   Elf32_Ehdr ehdr;				                        //Á‡„ÓÎÓ‚ÓÍ ÂÎ¸Ù‡
//  265   Elf32_Phdr phdrs[MAX_PHNUM];	                                        //Á‡„ÓÎÓ‚ÍË ÔÓ„‡Ï
//  266   Elf32_Word dyn[DT_BIND_NOW+1];	                                        //Ú˝„Ë ‰ËÌ‡ÏË˜ÂÒÍÓÈ ÒÂÍˆËË
//  267   char *reloc, *base;
//  268   unsigned long minadr=(unsigned long)-1, maxadr=0;//, maxadrsize;
        MOVS     R5,#+0
        MVNS     R5,R5
        STR      R5,[SP, #+8]
        MOVS     R6,#+0
//  269   int n,m;
//  270   /////////////////////////////////////////
//  271   //WINTEL
//  272 #ifdef wintel
//  273   FILE *fin=NULL;
//  274 
//  275   if ((fin=fopen(filename,"rb"))==NULL) return -1;			//ÌÂ ÓÚÍ˚‚‡ÂÚÒˇ ÂÎ¸Ù
//  276   if (fread(&ehdr,sizeof(Elf32_Ehdr),1,fin)!=1) return -2;	        //ÌÂ ˜ËÚ‡ÂÚÒˇ ÂÎ¸Ù
//  277 #endif
//  278 
//  279   //ARM
//  280 #ifndef wintel
//  281   int fin;
//  282   unsigned int iError, iError2;
//  283   if ((fin=fopen(filename, A_ReadOnly+A_BIN, P_READ, &iError))<0) return -1;	//ÌÂ ÓÚÍ˚‚‡ÂÚÒˇ ÂÎ¸Ù
        MOV      R3,SP
        MOVS     R2,#+128
        LSLS     R1,R2,#+8
        SVC      +10
        MOVS     R4,R0
        BPL      ??elfload_0
        MOVS     R0,R5
        B        ??elfload_1
//  284   if (fread(fin, &ehdr, sizeof(Elf32_Ehdr), &iError)!=sizeof(Elf32_Ehdr))	//ÌÂ ˜ËÚ‡ÂÚÒˇ ÂÎ¸Ù
??elfload_0:
        MOV      R3,SP
        MOVS     R2,#+52
        ADD      R1,SP,#+24
        SVC      +11
        CMP      R0,#+52
        BEQ      ??elfload_2
//  285   {fclose(fin, &iError); return -2;}
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,#+1
??elfload_3:
        MVNS     R0,R0
        B        ??elfload_1
//  286 #endif
//  287   /////////////////////////////////////////
//  288 
//  289   if (*((long *)ehdr.e_ident)!=0x464C457F){                               //‰‡ Ë ÌÂ ÂÎ¸Ù ˝ÚÓ ‚Ó‚ÒÂ
??elfload_2:
        LDR      R0,[SP, #+24]
        LDR      R1,??elfload_4   ;; 0x464c457f
        CMP      R0,R1
        BEQ      ??elfload_5
//  290 #ifndef wintel
//  291     fclose(fin, &iError);
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
//  292 #endif
//  293     return -3;
        MOVS     R0,#+2
        B.N      ??elfload_3
//  294   }
??elfload_5:
        ADD      R0,SP,#+24
        LDRH     R0,[R0, #+44]
        CMP      R0,#+11
        BCC      ??elfload_6
//  295 
//  296 #ifdef wintel
//  297   cout << "Elf header"<<endl;
//  298   cout << "ehdr.e_entry:"<<ehdr.e_entry<<endl;
//  299   cout << "ehdr.e_phoff:"<<ehdr.e_phoff<<endl;
//  300 #endif
//  301 
//  302   //ÔÓ˜ËÚ‡ÂÏ ‚ÒÂ ÔÓ„‡ÏÌ˚Â ÒÂ„ÏÂÌÚ˚ Ë ‚˚˜ËÒÎËÏ ÌÂÓ·ıÓ‰ËÏÛ˛ Ó·Î‡ÒÚ¸ ‚ ‡ÏÂ
//  303   if (ehdr.e_phnum>MAX_PHNUM) return -9;					//ÒÎË¯ÍÓÏ ÏÌÓ„Ó ÔÓ„‡ÏÌ˚ı ÒÂ„ÏÂÌÚÓ‚
        MOVS     R0,#+8
??elfload_7:
        MVNS     R0,R0
        B        ??elfload_1
//  304   for(n=0;n<ehdr.e_phnum;n++){
??elfload_6:
        MOVS     R5,#+0
        ADD      R7,SP,#+76
        ADDS     R7,R7,#+8
        B        ??elfload_8
//  305     ////////////////////////////////////////////////////
//  306     //WINTEL
//  307 #ifdef wintel
//  308     if (fseek(fin,ehdr.e_phoff+n*ehdr.e_phentsize,SEEK_SET)!=0) return -4;	//ÌÂ ÒËÍ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È Á‡„ÓÎÓ‚ÓÍ
//  309     if (fread(&(phdrs[n]),sizeof(Elf32_Phdr),1,fin)!=1) return -5;		//ÌÂ ˜ËÚ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È Á‡„ÓÎÓ‚ÓÍ
//  310 #endif
//  311 
//  312     //ARM
//  313 #ifndef wintel
//  314     if (lseek(fin, ehdr.e_phoff+n*ehdr.e_phentsize, S_SET, &iError, &iError2)!=ehdr.e_phoff+n*ehdr.e_phentsize)
//  315     {fclose(fin, &iError); return -4;}				//ÌÂ ÒËÍ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È Á‡„ÓÎÓ‚ÓÍ
//  316     if (fread(fin, &phdrs[n], sizeof(Elf32_Phdr), &iError)!=sizeof(Elf32_Phdr))
//  317     {fclose(fin, &iError); return -5;}				//ÌÂ ˜ËÚ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È Á‡„ÓÎÓ‚ÓÍ
//  318 #endif
//  319     /////////////////////////////////////////////////////
//  320     if (phdrs[n].p_type==PT_LOAD) {
??elfload_9:
        MOVS     R0,R7
        SUBS     R0,R0,#+8
        LDR      R0,[R0, #+0]
        CMP      R0,#+1
        BNE      ??elfload_10
//  321       if (minadr>phdrs[n].p_vaddr) minadr=phdrs[n].p_vaddr;
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BCS      ??elfload_11
        STR      R0,[SP, #+8]
//  322       if (maxadr<(phdrs[n].p_vaddr+phdrs[n].p_memsz))
??elfload_11:
        LDR      R1,[R7, #+12]
        ADDS     R0,R0,R1
        CMP      R6,R0
        BCS      ??elfload_10
//  323       {
//  324 	maxadr=phdrs[n].p_vaddr+phdrs[n].p_memsz;
        LDR      R0,[R7, #+0]
        ADDS     R6,R0,R1
//  325       }
//  326     }
??elfload_10:
        ADDS     R5,R5,#+1
        ADDS     R7,R7,#+32
??elfload_8:
        ADD      R0,SP,#+24
        LDRH     R0,[R0, #+44]
        CMP      R5,R0
        BGE      ??elfload_12
        ADD      R0,SP,#+20
        PUSH     {R0}
        CFI CFA R13+536
        LDR      R0,[SP, #+56]
        ADD      R1,SP,#+28
        LDRH     R1,[R1, #+42]
        ADD      R3,SP,#+4
        MOVS     R2,#+0
        MULS     R1,R5,R1
        ADDS     R1,R0,R1
        MOVS     R0,R4
        SVC      +15
        LDR      R1,[SP, #+56]
        ADD      R2,SP,#+28
        LDRH     R2,[R2, #+42]
        ADD      SP,SP,#+4
        CFI CFA R13+532
        MULS     R2,R5,R2
        ADDS     R1,R1,R2
        CMP      R0,R1
        BEQ      ??elfload_13
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,#+3
        B.N      ??elfload_3
??elfload_13:
        MOV      R3,SP
        MOVS     R2,#+32
        MOVS     R1,R7
        SUBS     R1,R1,#+8
        MOVS     R0,R4
        SVC      +11
        CMP      R0,#+32
        BEQ      ??elfload_9
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,#+4
        B.N      ??elfload_7
//  327 #ifdef wintel
//  328     cout << "Program header"<<endl;
//  329     cout << "phdr.p_type:"<<phdrs[n].p_type<<endl;
//  330     cout << "phdr.p_offset:"<<phdrs[n].p_offset<<endl;
//  331     cout << "phdr.p_vaddr:"<<phdrs[n].p_vaddr<<endl;
//  332     cout << "phdr.p_paddr:"<<phdrs[n].p_paddr<<endl;
//  333     cout << "phdr.p_filesz:"<<phdrs[n].p_filesz<<endl;
//  334 #endif
//  335   }
//  336 
//  337   //‚˚‰ÂÎËÏ ˝ÚÛ Ó·Î‡ÒÚ¸ Ë Ó˜ËÒÚËÏ ÂÂ
//  338   if ((base=(char *)malloc(maxadr-minadr))==0){		//ÌÂ ‚˚‰ÂÎˇÂÚ¸Òˇ Ô‡ÏˇÚ¸ ÔÓ‰ ÂÎ¸Ù
??elfload_12:
        LDR      R0,[SP, #+8]
        SUBS     R5,R6,R0
        MOVS     R0,R5
        SVC      +20
        MOVS     R6,R0
        BNE      ??elfload_14
//  339 #ifndef wintel
//  340     fclose(fin, &iError);
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
//  341 #endif
//  342     return -14;
        MOVS     R0,#+13
        B.N      ??elfload_3
//  343   }
//  344   zeromem_a(base,maxadr-minadr);
??elfload_14:
        MOVS     R1,R5
        BLX      zeromem_a
//  345   for(n=0;n<ehdr.e_phnum;n++){
        MOVS     R5,#+0
        ADD      R0,SP,#+76
        B.N      ??elfload_15
//  346     ////////////////////////////////////////////////////////////////////
//  347     //WINTEL
//  348 #ifdef wintel
//  349     if (fseek(fin,phdrs[n].p_offset,SEEK_SET)!=0) return -6;	//ÌÂ ÒËÍ‡ÂÚÒˇ ‰ËÌ‡ÏË˜ÂÒÍËÈ ÒÂ„ÏÂÌÚ
//  350 #endif
//  351 
//  352     //ARM
//  353 #ifndef wintel
//  354     if (lseek(fin, phdrs[n].p_offset, S_SET, &iError, &iError)!=phdrs[n].p_offset)
//  355     {fclose(fin, &iError); mfree(base); return -6;}		//ÌÂ ÒËÍ‡ÂÚÒˇ ‰ËÌ‡ÏË˜ÂÒÍËÈ ÒÂ„ÏÂÌÚ
//  356 #endif
//  357     /////////////////////////////////////////////////////////////////////
//  358     switch (phdrs[n].p_type){
??elfload_16:
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+0]
        CMP      R0,#+1
        BEQ      ??elfload_17
        CMP      R0,#+2
        BEQ      ??elfload_18
        B        ??elfload_19
//  359     case PT_LOAD:
//  360       //Á‡„ÛÁÂÏ ÔÓ„‡ÏÌ˚Â ÒÂ„ÏÂÌÚ˚ Ò ‡ÁÏÂÓÏ ·ÓÎ¸¯Â 0
//  361       if (phdrs[n].p_filesz!=0) {
??elfload_17:
        LDR      R0,[SP, #+4]
        LDR      R2,[R0, #+16]
        CMP      R2,#+0
        BEQ      ??elfload_20
//  362 	/////////////////////////////////////////////////////////////////////
//  363 	//WINTEL
//  364 #ifdef wintel
//  365 	if (fread((void *)&base[phdrs[n].p_vaddr-minadr],phdrs[n].p_filesz,1,fin)!=1) return -11;	//ÌÂ ˜ËÚ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È ÒÂ„ÏÂÌÚ
//  366 #endif
//  367 	
//  368 	//ARM
//  369 #ifndef wintel
//  370 	if (fread(fin, &base[phdrs[n].p_vaddr-minadr], phdrs[n].p_filesz, &iError)!= phdrs[n].p_filesz)
        LDR      R0,[R0, #+8]
        LDR      R1,[SP, #+8]
        MOV      R3,SP
        SUBS     R0,R0,R1
        ADDS     R1,R6,R0
        MOVS     R0,R4
        SVC      +11
        LDR      R1,[SP, #+4]
        LDR      R1,[R1, #+16]
        CMP      R0,R1
        BEQ      ??elfload_20
//  371 	{fclose(fin, &iError); mfree(base); return -11;}//ÌÂ ˜ËÚ‡ÂÚÒˇ ÔÓ„‡ÏÌ˚È ÒÂ„ÏÂÌÚ
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,R6
        SVC      +21
        MOVS     R0,#+10
??elfload_21:
        MVNS     R0,R0
        B        ??elfload_1
//  372 #endif
//  373 	///////////////////////////////////////////////////////////////////////
//  374       }
//  375       break;
//  376     case PT_DYNAMIC:
//  377       //ÔÓ˜ÚÂÏ ‰ËÌ‡ÏË˜ÂÒÍÛ˛ ÒÂÍˆË˛
//  378       if ((reloc=(char *)malloc(phdrs[n].p_filesz))==0) {//ÌÂ ‚˚‰ÂÎˇÂÚÒˇ ‡Ï‡ ÔÓ‰ ‰ËÌ‡ÏË˜ÂÒÍËÈ ÒÂ„ÏÂÌÚ
??elfload_18:
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+16]
        SVC      +20
        MOVS     R7,R0
        BNE      ??elfload_22
//  379 #ifndef wintel
//  380 	fclose(fin, &iError);
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
//  381 #endif
//  382 	mfree(base);
        MOVS     R0,R6
        SVC      +21
//  383 	return -7;
        MOVS     R0,#+6
        B.N      ??elfload_3
//  384       }
//  385       ///////////////////////////////////////////////////////////////////////
//  386       //WINTEL
//  387 #ifdef wintel
//  388       if (fread(reloc,phdrs[n].p_filesz,1,fin)!=1) {mfree(reloc); return -8;} //ÌÂ ˜ËÚ‡ÂÚÒˇ ‰ËÌ‡ÏË˜ÂÒÍËÈ ÒÂ„ÏÂÌÚ
//  389 #endif
//  390 
//  391       //ARM
//  392 #ifndef wintel
//  393       if (fread(fin, reloc, phdrs[n].p_filesz, &iError)!=phdrs[n].p_filesz)
??elfload_22:
        LDR      R0,[SP, #+4]
        MOV      R3,SP
        LDR      R2,[R0, #+16]
        MOVS     R1,R7
        MOVS     R0,R4
        SVC      +11
        LDR      R1,[SP, #+4]
        LDR      R1,[R1, #+16]
        CMP      R0,R1
        BEQ      ??elfload_23
//  394       {fclose(fin, &iError); mfree(reloc); mfree (base); return -8;}	//ÌÂ ˜ËÚ‡ÂÚÒˇ ‰ËÌ‡ÏË˜ÂÒÍËÈ ÒÂ„ÏÂÌÚ
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,R7
        SVC      +21
        MOVS     R0,R6
        SVC      +21
        MOVS     R0,#+7
        B.N      ??elfload_7
//  395 #endif
//  396       ////////////////////////////////////////////////////////////////////////
//  397       //				memset(dyn,0, sizeof(dyn));
//  398       //‚˚Ú‡˘ËÏ ‚ÒÂ Ú˝„Ë ËÁ ‰ËÌ‡ÏË˜ÂÒÍÓÈ ÒÂÍˆËË
//  399       m=0;
??elfload_23:
        MOVS     R0,R7
        B        ??elfload_24
//  400       while (((Elf32_Dyn *)reloc)[m].d_tag!=0){
//  401 	if (((Elf32_Dyn *)reloc)[m].d_tag<=DT_BIND_NOW) {
??elfload_25:
        CMP      R1,#+25
        BGE      ??elfload_26
//  402 	  dyn[((Elf32_Dyn *)reloc)[m].d_tag]=((Elf32_Dyn *)reloc)[m].d_val;
        LDR      R2,[R0, #+4]
        LSLS     R3,R1,#+2
        ADD      R1,SP,#+396
        STR      R2,[R1, R3]
//  403 	}
//  404 	m++;
??elfload_26:
        ADDS     R0,R0,#+8
//  405       }
??elfload_24:
        LDR      R1,[R0, #+0]
        CMP      R1,#+0
        BNE      ??elfload_25
//  406 #ifdef wintel
//  407       cout << "Dynamic section" << endl;
//  408       for (m = 0; m <= DT_BIND_NOW; m++) {
//  409 	cout << m<<" = "<<dyn[m]<<endl;
//  410       }
//  411 #endif
//  412       m=0;
//  413       //‚˚ÔÓÎÌËÏ ÂÎÓÍ‡ˆË˛ REL
//  414       if (dyn[DT_RELSZ]!=0) {
        LDR      R1,[SP, #+468]
        MOVS     R0,#+0
        STR      R1,[SP, #+12]
        CMP      R1,#+0
        BNE      ??elfload_27
//  415 	while (m*sizeof(Elf32_Rel)<dyn[DT_RELSZ]){
//  416 #ifdef wintel
//  417 	  cout<<((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_offset
//  418 	    <<" , "<<ELF32_R_SYM(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)
//  419 	      <<" , "<<(int) ELF32_R_TYPE(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)<<endl;
//  420 #endif
//  421 	  switch(ELF32_R_TYPE(((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_info)){
//  422 	  case R_ARM_RABS32:
//  423 	    *((long*)(base+((Elf32_Rel *)(reloc+dyn[DT_REL]))[m].r_offset-minadr))+=(long)base-minadr;
//  424 	    break;
//  425 	  case R_ARM_RBASE: break;
//  426 	  default: 	//ÌÂËÁ‚ÂÒÚÌ˚È ÚËÔ ÂÎÓÍ‡ˆËË
//  427 #ifndef wintel
//  428 	    fclose(fin, &iError);
//  429 #endif
//  430 	    mfree(base);
//  431 	    mfree(reloc);
//  432 	    return -13;
//  433 	  }
//  434 	  m++;
//  435 	}
//  436       }
//  437       mfree(reloc);
??elfload_28:
        MOVS     R0,R7
        SVC      +21
??elfload_20:
        LDR      R0,[SP, #+4]
        ADDS     R5,R5,#+1
        ADDS     R0,R0,#+32
??elfload_15:
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+8]
        RSBS     R1,R0,#+0
        STR      R1,[SP, #+16]
        ADD      R0,SP,#+24
        LDRH     R0,[R0, #+44]
        CMP      R5,R0
        BGE      ??elfload_29
        MOV      R0,SP
        PUSH     {R0}
        CFI CFA R13+536
        LDR      R0,[SP, #+8]
        ADD      R3,SP,#+4
        LDR      R1,[R0, #+4]
        MOVS     R2,#+0
        MOVS     R0,R4
        SVC      +15
        LDR      R1,[SP, #+8]
        LDR      R1,[R1, #+4]
        ADD      SP,SP,#+4
        CFI CFA R13+532
        CMP      R0,R1
        BEQ      ??elfload_16
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,R6
        SVC      +21
        MOVS     R0,#+5
        B.N      ??elfload_3
??elfload_30:
        LDR      R1,[SP, #+16]
        LDR      R3,[R2, #+0]
        ADDS     R1,R6,R1
        LDR      R2,[R1, R3]
        MOV      R12,R3
        ADDS     R3,R2,R6
        LDR      R2,[SP, #+8]
        SUBS     R2,R3,R2
        MOV      R3,R12
        STR      R2,[R1, R3]
??elfload_31:
        ADDS     R0,R0,#+1
??elfload_27:
        LDR      R2,[SP, #+12]
        LSLS     R1,R0,#+3
        CMP      R1,R2
        BCS      ??elfload_28
        LDR      R2,[SP, #+464]
        ADDS     R2,R7,R2
        ADDS     R2,R2,R1
        LDR      R1,[R2, #+4]
        LSLS     R1,R1,#+24
        LSRS     R1,R1,#+24
        CMP      R1,#+253
        BEQ      ??elfload_30
        CMP      R1,#+255
        BEQ      ??elfload_31
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
        MOVS     R0,R6
        SVC      +21
        MOVS     R0,R7
        SVC      +21
        MOVS     R0,#+12
        B.N      ??elfload_21
//  438       break;
//  439     default:	//ÌÂËÁ‚ÂÒÚÌ˚È ÚËÔ ÔÓ„‡ÏÌÓ„Ó ÒÂ„ÏÂÌÚ‡
//  440 #ifndef wintel
//  441       fclose(fin, &iError);
??elfload_19:
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
//  442 #endif
//  443       mfree(base);
        MOVS     R0,R6
        SVC      +21
//  444       return -12;
        MOVS     R0,#+11
        B.N      ??elfload_3
//  445     }
//  446   }
//  447 #ifndef wintel
//  448   fclose(fin, &iError);
??elfload_29:
        MOV      R1,SP
        MOVS     R0,R4
        SVC      +13
//  449   {
//  450     extern __arm void ExecuteIMB(void);
//  451     ExecuteIMB();	
        _BLF     ExecuteIMB,??ExecuteIMB??rT
//  452   }
//  453   ((TElfEntry *)(base+ehdr.e_entry-minadr))(filename,param1,param2,param3);
        LDR      R4,[SP, #+16]
        LDR      R5,[SP, #+48]
        LDR      R3,[SP, #+508]
        LDR      R2,[SP, #+504]
        LDR      R1,[SP, #+500]
        LDR      R0,[SP, #+496]
        ADDS     R5,R6,R5
        ADDS     R4,R5,R4
        BLX      R4
//  454   //	mfree(base);
//  455   return 0;
        MOVS     R0,#+0
??elfload_1:
        ADD      SP,SP,#+508
        CFI CFA R13+24
        ADD      SP,SP,#+4
        CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        DATA
??elfload_4:
        DC32     0x464c457f
        CFI EndBlock cfiBlock3
//  456 #endif
//  457 #ifdef wintel
//  458   FILE fout;
//  459   char foutbuff[10];
//  460   sprintf(foutbuff,"0x%08x",base);
//  461   if ((fin=fopen(foutbuff,"wb"))==NULL) return -1000;
//  462   if (fwrite(base,maxadr+maxadrsize-minadr,1,fin)!=1) return -1001;
//  463   return 0;
//  464 #endif
//  465 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock4 Using cfiCommon1
        CFI NoFunction
        ARM
??elfloader_onload??rA:
        ADD      R12,PC,#+1
        BX       R12
        CFI EndBlock cfiBlock4
        REQUIRE elfloader_onload
//  466 
//  467 #ifdef wintel
//  468 int main(int argc, char* argv[]){
//  469   cout << elfload(argv[1],0,0,0);
//  470   return 1;
//  471 }
//  472 #endif
//  473 
//  474 #ifndef wintel

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock5 Using cfiCommon0
        CFI Function elfloader_onload
        THUMB
//  475 void elfloader_onload(WSHDR *filename){
elfloader_onload:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        SUB      SP,SP,#+128
        CFI CFA R13+132
//  476   char fn[128];
//  477   ws_2str(filename,fn,126);
        MOVS     R2,#+126
        MOV      R1,SP
        SVC      +163
//  478   elfload(fn,0,0,0);
        MOVS     R3,#+0
        MOVS     R2,#+0
        MOVS     R1,R2
        MOV      R0,SP
        BL       elfload
//  479 }
        ADD      SP,SP,#+128
        CFI CFA R13+4
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock5

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock6 Using cfiCommon0
        CFI NoFunction
        THUMB
??MyIDLECSMonClose??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock6
        REQUIRE MyIDLECSMonClose
//  480 
//  481 //=======================================================================
//  482 //
//  483 //=======================================================================
//  484 extern void(*OldOnClose)(void *);
//  485 extern void(*OldOnCreate)(void *);
//  486 extern void(*OldShowMsg)(int, int);
//  487 
//  488 //-----------------------------------------------------------------------
//  489 
//  490 #define HELPER_CEPID 0x4339
//  491 #define MSG_HELPER_RUN 0x0001
//  492 

        RSEG HELPER_PROC:CODE:NOROOT(2)
        CFI Block cfiBlock7 Using cfiCommon1
        CFI Function proc_HELPER
        ARM
//  493 __arm void proc_HELPER(void) @ "HELPER_PROC"
//  494 {
proc_HELPER:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        SUB      SP,SP,#+20
        CFI CFA R13+24
//  495   GBS_MSG msg;
//  496   if (GBS_RecActDstMessage(&msg))
        MOV      R0,SP
        SWI      +339
        CMP      R0,#+0
        BEQ      ??proc_HELPER_0
//  497   {
//  498     if (msg.msg==MSG_HELPER_RUN)
        LDR      R0,[SP, #+4]
        CMP      R0,#+1
        BNE      ??proc_HELPER_0
//  499     {
//  500       if (msg.data0)
        LDR      R2,[SP, #+12]
        CMP      R2,#+0
        BEQ      ??proc_HELPER_0
//  501       {
//  502 	((void (*)(int, void *))(msg.data0))(msg.submess,msg.data1);
        LDR      R1,[SP, #+16]
        LDR      R0,[SP, #+8]
        BLX      R2
//  503       }
//  504     }
//  505   }
//  506 }
??proc_HELPER_0:
        ADD      SP,SP,#+20       ;; stack cleaning
        CFI CFA R13+4
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock7
//  507 

        RSEG HELPER_PROC:CODE:NOROOT(2)
        CFI Block cfiBlock8 Using cfiCommon1
        CFI Function CreateHELPER_PROC
        ARM
//  508 __arm void CreateHELPER_PROC(void) @ "HELPER_PROC"
//  509 {
CreateHELPER_PROC:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  510   static const char name[] @ "HELPER_PROC_DATA" ="HELPER";
//  511   CreateGBSproc(HELPER_CEPID, name, proc_HELPER, 0x80, 0);
        LDR      R2,??CreateHELPER_PROC_0  ;; proc_HELPER
        LDR      R1,??CreateHELPER_PROC_0+0x4  ;; ??name
        MOV      R0,#+0
        PUSH     {R0}
        CFI CFA R13+8
        MOV      R3,#+128
        MOV      R0,#+57
        ORR      R0,R0,#0x4300
        SWI      +261
//  512 }
        ADD      SP,SP,#+4
        CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??CreateHELPER_PROC_0:
        DC32     proc_HELPER
        DC32     ??name
        CFI EndBlock cfiBlock8

        RSEG HELPER_PROC_DATA:CONST:SORT:NOROOT(2)
??name:
        DATA
        DC8 "HELPER"
        DC8 0
//  513 

        RSEG HELPER_PROC:CODE:NOROOT(2)
        CFI Block cfiBlock9 Using cfiCommon1
        CFI Function REDRAW_impl
        ARM
//  514 __arm void REDRAW_impl(void) @"HELPER_PROC"
//  515 {
REDRAW_impl:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  516   LockSched();
        SWI      +326
//  517 #ifdef NEWSGOLD
//  518   PendedRedrawGUI();
        SWI      +321
//  519 #else
//  520   PendedRedrawGUI();
//  521   GBS_SendMessage(MMI_CEPID,0x91);
//  522 #endif
//  523   UnlockSched();
        SWI      +327
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock9
//  524 }
//  525 

        RSEG HELPER_PROC:CODE:NOROOT(2)
        CFI Block cfiBlock10 Using cfiCommon1
        CFI Function SUBPROC_impl
        ARM
//  526 __arm void SUBPROC_impl(void *f, int p2, void *p1) @ "HELPER_PROC"
//  527 {
SUBPROC_impl:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  528   GBS_SendMessage(HELPER_CEPID,MSG_HELPER_RUN,p2,f,p1);
        PUSH     {R2}
        CFI CFA R13+8
        MOV      R3,R0
        MOV      R0,#+57
        ORR      R0,R0,#0x4300
        MOV      R2,R1
        MOV      R1,#+1
        SWI      +256
//  529 }
        ADD      SP,SP,#+4
        CFI CFA R13+4
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock10
//  530 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock11 Using cfiCommon1
        CFI Function MyIDLECSMonClose
        ARM
//  531 __arm void MyIDLECSMonClose(void *data)
//  532 {
MyIDLECSMonClose:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        MOV      R4,R0
//  533   KillGBSproc(HELPER_CEPID);
        MOV      R0,#+57
        ORR      R0,R0,#0x4300
        SWI      +340
//  534   OldOnClose(data);
        LDR      R1,??MyIDLECSMonClose_0  ;; OldOnClose
        MOV      R0,R4
        LDR      R1,[R1, #+0]
        BLX      R1
//  535   asm("NOP\n");
        NOP
             
        POP      {R4,PC}          ;; return
        DATA
??MyIDLECSMonClose_0:
        DC32     OldOnClose
        CFI EndBlock cfiBlock11
//  536 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        THUMB
??LoadDaemons??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock12
        REQUIRE LoadDaemons
//  537 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock13 Using cfiCommon1
        CFI Function LoadDaemons
        ARM
//  538 __arm void LoadDaemons(int dummy, char *path)
//  539 {
LoadDaemons:
        PUSH     {R4,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R4 Frame(CFA, -8)
        CFI CFA R13+8
        SUB      SP,SP,#+72
        CFI CFA R13+80
        SUB      SP,SP,#+1024
        CFI CFA R13+1104
        MOV      R4,R1
//  540   DIR_ENTRY de;
//  541   unsigned int err;
//  542   char name[256];
//  543   strcpy(name,path);
        ADD      R0,SP,#+840
        SWI      +26
//  544   strcat(name,"*.elf");
        LDR      R1,??LoadDaemons_0  ;; `?<Constant "*.elf">`
        ADD      R0,SP,#+840
        SWI      +23
//  545   if (FindFirstFile(&de,name,&err))
        MOV      R2,SP
        ADD      R1,SP,#+840
        ADD      R0,SP,#+4
        SWI      +107
        CMP      R0,#+0
        BEQ      ??LoadDaemons_1
//  546   {
//  547     do
//  548     {
//  549       strcpy(name,path);
??LoadDaemons_2:
        MOV      R1,R4
        ADD      R0,SP,#+840
        SWI      +26
//  550       strcat(name,de.file_name);
        ADD      R1,SP,#+185
        ADD      R0,SP,#+840
        SWI      +23
//  551       elfload(name,0,0,0);
        MOV      R3,#+0
        MOV      R2,#+0
        MOV      R1,R2
        ADD      R0,SP,#+840
        BLX      elfload
//  552     }
//  553     while(FindNextFile(&de,&err));
        MOV      R1,SP
        ADD      R0,SP,#+4
        SWI      +108
        CMP      R0,#+0
        BNE      ??LoadDaemons_2
//  554   }
//  555   FindClose(&de,&err);
??LoadDaemons_1:
        MOV      R1,SP
        ADD      R0,SP,#+4
        SWI      +109
//  556 }
        ADD      SP,SP,#+72
        CFI CFA R13+1032
        ADD      SP,SP,#+1024
        CFI CFA R13+8
        POP      {R4,PC}          ;; return
        DATA
??LoadDaemons_0:
        DC32     `?<Constant "*.elf">`
        CFI EndBlock cfiBlock13

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock14 Using cfiCommon0
        CFI NoFunction
        THUMB
??MyIDLECSMonCreate??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock14
        REQUIRE MyIDLECSMonCreate
//  557 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock15 Using cfiCommon1
        CFI Function MyIDLECSMonCreate
        ARM
//  558 __arm void MyIDLECSMonCreate(void *data)
//  559 {
MyIDLECSMonCreate:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
        LDR      R5,??MyIDLECSMonCreate_0  ;; `?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`
        MOV      R4,R0
//  560   static const int smallicons[2]={0x3f5,0};
//  561   static const int bigicons[2]={0x439,0};
//  562   static const REGEXPLEXT elf_reg=
//  563   {
//  564     "elf",
//  565     0x55,
//  566     //   0x59C1200,
//  567     0x59D43FF,
//  568 //    0x5431F04,
//  569     smallicons,
//  570     bigicons,
//  571     //   0xBB,
//  572     0x109,
//  573     0x197,
//  574     //   0x7FFFC112,
//  575     0x7FFFC0FB,
//  576     (void *)elfloader_onload,
//  577     0
//  578 
//  579   };
//  580   CreateHELPER_PROC();
        _BLF     CreateHELPER_PROC,??CreateHELPER_PROC??rA
//  581   RegExplorerExt(&elf_reg);
        ADD      R0,R5,#+20
        SWI      +140
//  582   SUBPROC((void *)LoadDaemons,0,"4:\\ZBin\\Daemons\\");
        LDR      R0,??MyIDLECSMonCreate_0+0x4  ;; LoadDaemons
        MOV      R2,R5
        MOV      R1,#+0
        SWI      +369
//  583   OldOnCreate(data);
        LDR      R1,??MyIDLECSMonCreate_0+0x8  ;; OldOnCreate
        MOV      R0,R4
        LDR      R1,[R1, #+0]
        BLX      R1
//  584   asm("NOP\n");
        NOP
             
        POP      {R4,R5,PC}       ;; return
        DATA
??MyIDLECSMonCreate_0:
        DC32     `?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`
        DC32     LoadDaemons
        DC32     OldOnCreate
        CFI EndBlock cfiBlock15
//  585 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock16 Using cfiCommon0
        CFI NoFunction
        THUMB
??ESI??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock16
        REQUIRE ESI

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "*.elf">`:
        DATA
        DC8 "*.elf"
        DC8 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "4:\\\\ZBin\\\\Daemons\\\\">`:
        DATA
        DC8 "4:\\ZBin\\Daemons\\"
        DC8 0, 0, 0
        DC32 `?<Constant "elf">`, 85, 94192639, ??smallicons, ??bigicons, 265
        DC32 407, 2147467515, elfloader_onload, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "elf">`:
        DATA
        DC8 "elf"

        RSEG DATA_C:CONST:SORT:NOROOT(0)
        DATA
        DC8 ""
//  586 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock17 Using cfiCommon1
        CFI Function ESI
        ARM
//  587 __arm void ESI(WSHDR *ws, int dummy, char *s)
//  588 {
ESI:
        PUSH     {R4,R5,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R5 Frame(CFA, -8)
        CFI R4 Frame(CFA, -12)
        CFI CFA R13+12
//  589   int c;
//  590   CutWSTR(ws,0);
        MOV      R1,#+0
        MOV      R4,R0
        MOV      R5,R2
        SWI      +294
        B        ??ESI_0
//  591   while((c=*s++))
//  592   {
//  593     if (c>=0xC0) c+=0x350;
??ESI_1:
        CMP      R1,#+192
        ADDGE    R1,R1,#+848
//  594     wsAppendChar(ws,c);
        MOV      R0,R4
        SWI      +28
//  595   }
??ESI_0:
        LDRB     R1,[R5], #+1
        CMP      R1,#+0
        BNE      ??ESI_1
//  596 }
        POP      {R4,R5,PC}       ;; return
        CFI EndBlock cfiBlock17

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock18 Using cfiCommon1
        CFI NoFunction
        ARM
??toupper??rA:
        ADD      R12,PC,#+1
        BX       R12
        CFI EndBlock cfiBlock18
        REQUIRE toupper
//  597 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock19 Using cfiCommon0
        CFI Function toupper
        THUMB
//  598 int toupper(int c)
//  599 {
toupper:
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
//  600   if ((c>='a')&&(c<='z')) c+='A'-'a';
        CMP      R0,#+97
        BLT      ??toupper_0
        CMP      R0,#+123
        BGE      ??toupper_0
        SUBS     R0,R0,#+32
//  601   return(c);
??toupper_0:
        POP      {PC}             ;; return
        CFI EndBlock cfiBlock19
//  602 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock20 Using cfiCommon0
        CFI NoFunction
        THUMB
??DoUnknownFileType??rT:
        BX       PC
        Nop      
        CFI EndBlock cfiBlock20
        REQUIRE DoUnknownFileType
//  603 

        RSEG DATA_C:CONST:SORT:NOROOT(2)
`?<Constant "Nothing to run!">`:
        DATA
        DC8 "Nothing to run!"
        DC8 "Can't run ELF!"
        DC8 0
        DC8 "Elfs.ext not found!"
        DC8 "4:\\ZBin\\etc\\extension.cfg"
        DC8 0, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
??smallicons:
        DATA
        DC32 1013, 0

        RSEG DATA_C:CONST:SORT:NOROOT(2)
??bigicons:
        DATA
        DC32 1081, 0
//  604 static const char extfile[]="4:\\ZBin\\etc\\extension.cfg";
//  605 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock21 Using cfiCommon1
        CFI Function DoUnknownFileType
        ARM
//  606 __arm int DoUnknownFileType(WSHDR *filename)
//  607 {
DoUnknownFileType:
        PUSH     {R4-R11,LR}
        CFI ?RET Frame(CFA, -4)
        CFI R11 Frame(CFA, -8)
        CFI R10 Frame(CFA, -12)
        CFI R9 Frame(CFA, -16)
        CFI R8 Frame(CFA, -20)
        CFI R7 Frame(CFA, -24)
        CFI R6 Frame(CFA, -28)
        CFI R5 Frame(CFA, -32)
        CFI R4 Frame(CFA, -36)
        CFI CFA R13+36
        SUB      SP,SP,#+392
        CFI CFA R13+428
//  608   char fn[128];
//  609   char s[256];
//  610   int f;
//  611   unsigned int i;
//  612   unsigned int mi;
//  613   int c;
//  614   unsigned int sm=0;
        MOV      R4,#+0
        MOV      R6,#+0
//  615   char *execname=0;
        MOV      R5,R4
//  616   char *fname;
//  617   unsigned int ul;
//  618 
//  619   ws_2str(filename,fn,126);
        MOV      R2,#+126
        ADD      R1,SP,#+264
        SWI      +163
//  620 
//  621   i=strlen(fn);
        ADD      R0,SP,#+264
        SWI      +27
        MOVS     R8,R0
        BNE      ??DoUnknownFileType_0
//  622   if (!i) return 0;
??DoUnknownFileType_1:
        MOV      R0,#+0
??DoUnknownFileType_2:
        ADD      SP,SP,#+392      ;; stack cleaning
        CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        CFI CFA R13+428
//  623   if (i>127) return 0;
??DoUnknownFileType_0:
        CMP      R8,#+128
        BCS      ??DoUnknownFileType_1
//  624 
//  625   fname=fn+i; //”Í‡Á‡ÚÂÎ¸ Ì‡ ÔÓÒÎ. ·‡ÈÚ
        ADD      R0,SP,#+264
        ADD      R7,R8,R0
        SUB      R0,R7,#+1
        B        ??DoUnknownFileType_3
//  626   while(fname[-1]!='.')
//  627   {
//  628     i--;
//  629     if (i==0) {
//  630       fname="";
//  631       break;
//  632     }
//  633     fname--;
??DoUnknownFileType_4:
        SUB      R7,R7,#+1
??DoUnknownFileType_3:
        LDRB     R1,[R0], #-1
        CMP      R1,#+46
        BEQ      ??DoUnknownFileType_5
        SUBS     R8,R8,#+1
        BNE      ??DoUnknownFileType_4
        ADR      R7,??DoUnknownFileType_6  ;; ""
??DoUnknownFileType_5:
        LDR      R0,??DoUnknownFileType_6+0x4  ;; `?<Constant "Nothing to run!">` + 52
        MOV      R3,SP
        MOV      R2,#+0
        MOV      R1,R2
//  634   }
//  635   //“ÂÔÂ¸ fname ÛÍ‡Á˚‚‡ÂÚ Ì‡ ‡Ò¯ËÂÌËÂ
//  636   if ((f=fopen(extfile,A_ReadOnly,0,&ul))!=-1)
        SWI      +10
        STR      R0,[SP, #+4]
        CMN      R0,#+1
        BEQ      ??DoUnknownFileType_7
//  637   {
//  638     i=fread(f,s,128,&ul);
        MOV      R3,SP
        MOV      R2,#+128
        ADD      R1,SP,#+8
        SWI      +11
        MOV      R8,R0
//  639     mi=128;
        MOV      R9,#+128
//  640     if (i<128)
        CMP      R8,#+128
        BCS      ??DoUnknownFileType_8
//  641       s[i]=0;
        ADD      R0,SP,#+8
        STRB     R4,[R8, +R0]
        B        ??DoUnknownFileType_9
//  642     else
//  643     {
//  644     L1:
//  645       i=fread(f,s+128,128,&ul);
//  646       if (i<128)
//  647       {
//  648 	(s+128)[i]=0;
//  649 	mi=256;
//  650       }
//  651     }
//  652     i=0;
//  653     for(;;)
//  654     {
//  655       if (i==mi)
//  656       {
//  657 	memcpy(s,s+128,128);
//  658 	goto L1;
//  659       }
//  660       c=s[i++];
//  661       if (!c) break; // ÓÌÂˆ Ù‡ÈÎ‡
//  662       switch(sm)
//  663       {
//  664       case 0xFFFF:
//  665 	//∆‰ÂÏ ÓÍÓÌ˜‡ÌËˇ ÒÚÓÍË
//  666 	if (c==':')
//  667 	{
//  668           execname=s+i; //œÓÒÎÂ‰ÌËÈ Ù‡ÈÎ - ÛÌË‚ÂÒ‡Î¸Ì˚È
//  669           sm--; //“ÓÎ¸ÍÓ ÔÂ‚˚È ‚ıÓ‰
//  670 	}
//  671       case 0xFFFE:
//  672 	if ((c==0x0D)||(c==0x0A)) sm=0; break;
//  673       default:
//  674 	if ((c==0x0D)||(c==0x0A))
//  675 	{
//  676           //ÕÂÓÊË‰‡ÌÌ˚È ÍÓÌÂˆ ÒÚÓÍË
//  677           sm=0;
//  678           break;
//  679 	}
//  680 	if ((c==':')&&(!fname[sm]))
//  681 	{
//  682           //œÓÎÌÓÂ ÒÓ‚Ô‡‰ÂÌËÂ
//  683           execname=s+i;
//  684           goto L_EOF;
//  685 	}
//  686 	if (toupper(c)==toupper(fname[sm])) sm++; else sm=0xFFFF;
//  687 	break;
//  688       }
//  689     }
//  690     if (!execname)
??DoUnknownFileType_10:
        CMP      R5,#+0
        BNE      ??DoUnknownFileType_11
//  691     {
//  692       ShowMSG(1,(int)"Nothing to run!");
        LDR      R1,??DoUnknownFileType_6+0x8  ;; `?<Constant "Nothing to run!">`
??DoUnknownFileType_12:
        MOV      R0,#+1
        SWI      +328
        B        ??DoUnknownFileType_1
//  693       return 0; //ÕÂÚ ÒÓÔÓÒÚ‡‚ÎÂÌËÈ
//  694     }
??DoUnknownFileType_13:
        CMP      R0,#+58
        BNE      ??DoUnknownFileType_14
        MOV      R5,R1
        SUB      R6,R6,#+1
??DoUnknownFileType_15:
        CMP      R8,R9
        BNE      ??DoUnknownFileType_16
??DoUnknownFileType_17:
        MOV      R2,#+128
        ADD      R1,SP,#+136
        ADD      R0,SP,#+8
        SWI      +286
??DoUnknownFileType_8:
        LDR      R0,[SP, #+4]
        MOV      R3,SP
        MOV      R2,#+128
        ADD      R1,SP,#+136
        SWI      +11
        MOV      R8,R0
        CMP      R8,#+128
        BCS      ??DoUnknownFileType_9
        ADD      R0,SP,#+8
        ADD      R0,R8,R0
        STRB     R4,[R0, #+128]
        MOV      R9,#+256
??DoUnknownFileType_9:
        MOV      R8,#+0
        CMP      R9,#+0
        BEQ      ??DoUnknownFileType_17
??DoUnknownFileType_16:
        ADD      R0,SP,#+8
        LDRB     R0,[R8, +R0]
        ADD      R8,R8,#+1
        CMP      R0,#+0
        BEQ      ??DoUnknownFileType_10
        ADD      R1,SP,#+8
        ADD      R1,R8,R1
        MOV      R3,#+254
        ORR      R3,R3,#0xFF00
        CMP      R6,R3
        BEQ      ??DoUnknownFileType_14
        ORR      R3,R3,#0x1
        CMP      R6,R3
        BEQ      ??DoUnknownFileType_13
        B        ??DoUnknownFileType_18
??DoUnknownFileType_14:
        CMP      R0,#+13
        CMPNE    R0,#+10
        BNE      ??DoUnknownFileType_15
??DoUnknownFileType_19:
        MOV      R6,#+0
        B        ??DoUnknownFileType_15
??DoUnknownFileType_18:
        CMP      R0,#+13
        CMPNE    R0,#+10
        BEQ      ??DoUnknownFileType_19
        ADD      R10,R6,R7
        CMP      R0,#+58
        LDRBEQ   R2,[R10, #+0]
        CMPEQ    R2,#+0
        BNE      ??DoUnknownFileType_20
        MOV      R5,R1
//  695   L_EOF:
//  696     fclose(f,&ul);
??DoUnknownFileType_11:
        LDR      R0,[SP, #+4]
        MOV      R1,SP
        SWI      +13
//  697     i=0;
        MOV      R8,#+0
        B        ??DoUnknownFileType_21
??DoUnknownFileType_20:
        BLX      toupper
        MOV      R11,R0
        LDRB     R0,[R10, #+0]
        BLX      toupper
        CMP      R11,R0
        MOVNE    R6,#+255
        ORRNE    R6,R6,#0xFF00
        ADDEQ    R6,R6,#+1
        B        ??DoUnknownFileType_15
//  698     while(execname[i]>31) i++;
??DoUnknownFileType_22:
        ADD      R8,R8,#+1
??DoUnknownFileType_21:
        ADD      R0,R8,R5
        LDRB     R1,[R0, #+0]
        CMP      R1,#+32
        BCS      ??DoUnknownFileType_22
//  699     execname[i]=0;
        STRB     R4,[R0, #+0]
//  700     if (elfload(execname,fn,0,0))
        MOV      R3,#+0
        MOV      R2,R3
        ADD      R1,SP,#+264
        MOV      R0,R5
        BLX      elfload
        CMP      R0,#+0
        BEQ      ??DoUnknownFileType_2
//  701     {
//  702       ShowMSG(1,(int)"Can't run ELF!");
        LDR      R1,??DoUnknownFileType_6+0xC  ;; `?<Constant "Nothing to run!">` + 16
??DoUnknownFileType_23:
        B        ??DoUnknownFileType_12
//  703     }
//  704   }
//  705   else
//  706   {
//  707     ShowMSG(1,(int)"Elfs.ext not found!");
??DoUnknownFileType_7:
        LDR      R1,??DoUnknownFileType_6+0x10  ;; `?<Constant "Nothing to run!">` + 32
        B        ??DoUnknownFileType_12
        DATA
??DoUnknownFileType_6:
        DC8      "",+0,+0,+0
        DC32     `?<Constant "Nothing to run!">` + 52
        DC32     `?<Constant "Nothing to run!">`
        DC32     `?<Constant "Nothing to run!">` + 16
        DC32     `?<Constant "Nothing to run!">` + 32
        CFI EndBlock cfiBlock21
//  708   }
//  709   return 0;
//  710 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock22 Using cfiCommon1
        CFI NoFunction
        ARM
??MyShowMSG??rA:
        ADD      R12,PC,#+1
        BX       R12
        CFI EndBlock cfiBlock22
        REQUIRE MyShowMSG
//  711 

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock23 Using cfiCommon0
        CFI Function MyShowMSG
        THUMB
//  712 __thumb MyShowMSG(int p1, int p2)
//  713 {
//  714   if (p2!=(0x1DCC+5))
MyShowMSG:
        LDR      R2,??MyShowMSG_0  ;; 0x1dd1
        PUSH     {LR}
        CFI ?RET Frame(CFA, -4)
        CFI CFA R13+4
        CMP      R1,R2
        BEQ      ??MyShowMSG_1
//  715   {
//  716     OldShowMsg(p1,p2);
        LDR      R2,??MyShowMSG_0+0x4  ;; OldShowMsg
        LDR      R2,[R2, #+0]
        BLX      R2
        POP      {PC}
//  717     return;
//  718   }
//  719   asm("MOVS R0,R6\n");
??MyShowMSG_1:
        MOVS R0,R6
        
//  720   DoUnknownFileType((WSHDR *)p1);
        BLX      DoUnknownFileType
        POP      {PC}             ;; return
        DATA
??MyShowMSG_0:
        DC32     0x1dd1
        DC32     OldShowMsg
        CFI EndBlock cfiBlock23
//  721 }

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock24 Using cfiCommon0
        CFI NoFunction
        THUMB
??ExecuteIMB??rT:
        LDR      R3,??Subroutine10_0  ;; ExecuteIMB
        BX       R3
        DATA
??Subroutine10_0:
        DC32     ExecuteIMB
        CFI EndBlock cfiBlock24

        RSEG CODE:CODE:NOROOT(2)
        CFI Block cfiBlock25 Using cfiCommon1
        CFI NoFunction
        ARM
??CreateHELPER_PROC??rA:
        LDR      R12,??Subroutine11_0  ;; CreateHELPER_PROC
        BX       R12
        DATA
??Subroutine11_0:
        DC32     CreateHELPER_PROC
        CFI EndBlock cfiBlock25
//  722 
//  723 
//  724 //œ‡Ú˜Ë
//  725 #pragma diag_suppress=Pe177

        RSEG PATCH_ONCREATE:CONST:SORT:ROOT(2)
        DATA
        DC32 MyIDLECSMonCreate
//  726 __root static const int NEW_ONCREATE @ "PATCH_ONCREATE" = (int)MyIDLECSMonCreate;
//  727 

        RSEG PATCH_ONCLOSE:CONST:SORT:ROOT(2)
        DATA
        DC32 MyIDLECSMonClose
//  728 __root static const int NEW_ONCLOSE @ "PATCH_ONCLOSE" = (int)MyIDLECSMonClose;
//  729 

        RSEG PATCH_SHOWMSG_BLF:CONST:SORT:ROOT(2)
        DATA
        DC32 MyShowMSG
//  730 __root static const int NEW_SHOWMSG @ "PATCH_SHOWMSG_BLF" = (int)MyShowMSG;
//  731 

        RSEG PATCH_TXT_EXT:CONST:SORT:ROOT(2)
        DATA
        DC32 DoUnknownFileType
//  732 __root static const int NEW_TXTEXT @ "PATCH_TXT_EXT" = (int)DoUnknownFileType;
//  733 

        RSEG SWILIB_FUNC171:CONST:SORT:ROOT(2)
        DATA
        DC32 SUBPROC_impl
//  734 __root static const int SWILIB_FUNC171 @ "SWILIB_FUNC171" = (int)SUBPROC_impl;
//  735 

        RSEG SWILIB_FUNC172:CONST:SORT:ROOT(2)
        DATA
        DC32 REDRAW_impl

        END
//  736 __root static const int SWILIB_FUNC172 @ "SWILIB_FUNC172" = (int)REDRAW_impl;
//  737 #pragma diag_default=Pe177
//  738 #endif
//  739 
// 
// 1 652 bytes in segment CODE
//   169 bytes in segment DATA_C
//   180 bytes in segment HELPER_PROC
//     8 bytes in segment HELPER_PROC_DATA
//     4 bytes in segment PATCH_ONCLOSE
//     4 bytes in segment PATCH_ONCREATE
//     4 bytes in segment PATCH_SHOWMSG_BLF
//     4 bytes in segment PATCH_TXT_EXT
//     4 bytes in segment SWILIB_FUNC171
//     4 bytes in segment SWILIB_FUNC172
// 
// 1 756 bytes of CODE  memory (+ 76 bytes shared)
//   201 bytes of CONST memory
//
//Errors: none
//Warnings: none
