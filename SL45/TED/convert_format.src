; C166/ST10 C compiler v7.5 r2            SN00123412-435 (c) 2001 TASKING, Inc.
; options: -e -Id:\c166\include -xmifp -DCPUTYPE=0x167 -FSC -Ob -znocustack
;          -zautobitastruct-4 -zautobita-0 -T256 -s -zvolatile_union -u
;          -AcdFiklmpstuVx -OAcdFghjkLnoprSUx -Ml
$EXTEND
$NOMOD166
$STDNAMES(reg.def)
$SEGMENTED
$CASE
$MODEL(LARGE)
	NAME	CONVERT_FORMAT_C
	ASSUME	DPP3:SYSTEM
; convert_format.c    1	#include "sl45.h"
; convert_format.c    2	
; convert_format.c    3	extern unsigned long curline; //Наружная переменная, счетчик строк
; convert_format.c    4	extern unsigned int max_x; //Наружная переменная - макс. размер строки
; convert_format.c    5	
; convert_format.c    6	extern unsigned char far dstk[];
; convert_format.c    7	extern unsigned char far ustk[];
; convert_format.c    8	
; convert_format.c    9	extern unsigned int FL_loader(int fin, unsigned int p);
; convert_format.c   10	extern unsigned int FL_saver(int fs, unsigned int p);
; convert_format.c   11	
; convert_format.c   12	extern char win_dos_koi;
; convert_format.c   13	extern char far wintranslation[];
; convert_format.c   14	extern char far koi8translation[];
; convert_format.c   15	
; convert_format.c   16	static const char ctype[128]=
CONVERT_FORMAT_1_FC	SECTION	DATA WORD PUBLIC 'CFARROM'
_ctype	LABEL	BYTE
	DB	02h,01h,01h,01h,01h
	DB	02h,01h,01h,02h,03h
	DB	01h,01h,01h,01h,02h
	DB	01h,01h,01h,01h,02h
	DB	01h,01h,01h,01h,01h
	DB	01h,03h,02h,03h,02h
	DB	02h,02h,02h,01h,01h
	DB	01h,01h,02h,01h,01h
	DB	02h,03h,01h,01h,01h
	DB	01h,02h,01h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h,00h,00h
	DB	00h,01h,01h,01h,02h
	DB	01h,01h,01h,01h,01h
	DB	01h,03h,02h,03h,02h
	DB	02h,02h,02h,02h,02h
	DB	02h,02h,02h,02h,02h
	DB	00h,00h,00h,00h,00h
	DB	00h,00h,00h
; convert_format.c   17	{
; convert_format.c   18	 2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
; convert_format.c   19	 1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
; convert_format.c   20	 2,1,1,1,1,2,1,1, 2,3,1,1,1,1,2,1,
; convert_format.c   21	 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
; convert_format.c   22	 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
; convert_format.c   23	 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
; convert_format.c   24	 1,1,1,2,1,1,1,1, 1,1,3,2,3,2,2,2,
; convert_format.c   25	 2,2,2,2,2,2,2,2, 0,0,0,0,0,0,0,0,
; convert_format.c   26	};
; convert_format.c   27	
; convert_format.c   28	int GetCharType_x(char c)
; convert_format.c   29	{
	PUBLIC	_GetCharType_x
CONVERT_FORMAT_1_FC	ENDS

CONVERT_FORMAT_2_PR	SECTION	CODE WORD PUBLIC 'CPROGRAM'
_GetCharType_x	PROC	FAR
	MOV	R1,R12
; Locals:
; 
; Statics:
; 
; CSEs:
;     c = RL1
; 
; convert_format.c   30	 if (c==' ') return(4); //Пробел
	CMPB	RL1,#020h
	JMPR	cc_NE,_18
	MOV	R4,#04h
	RETS
_18:
; convert_format.c   31	 if (c<32) return(5); //Конец строки
	CMPB	RL1,#020h
	JMPR	cc_UGE,_19
	MOV	R4,#05h
	RETS
_19:
; convert_format.c   32	 if ((c=='i')||(c=='I')) return 2; //Гласная для украинского ;)
	CMPB	RL1,#069h
	JMPR	cc_EQ,_20
	CMPB	RL1,#049h
	JMPR	cc_NE,_21
_20:
	MOV	R4,#02h
	RETS
_21:
; convert_format.c   33	 if (c<128) return(0); //Не русская буква
	MOVBZ	R12,RL1
	CMP	R12,#080h
	JMPR	cc_SLT,_26
; convert_format.c   34	 switch(win_dos_koi)
	EXTP	#PAG _win_dos_koi,#01h
	MOVB	RL2,POF _win_dos_koi
	CMPB	RL2,#01h
	JMPR	cc_EQ,_22
	CMPB	RL2,#02h
	JMPR	cc_EQ,_23
	JMPR	cc_UC,_25
; convert_format.c   35	 {
; convert_format.c   36	  case 1:
_22:
; convert_format.c   37	   //Win->Dos
; convert_format.c   38	   c=wintranslation[c-128];
	MOVBZ	R12,RL1
	EXTP	#PAG _wintranslation,#01h
	MOVB	RL1,[R12+#POF _wintranslation-128]
; convert_format.c   39	   break;
	JMPR	cc_UC,_25
; convert_format.c   40	  case 2:
_23:
; convert_format.c   41	   //Koi8->Dos
; convert_format.c   42	   c=koi8translation[c-128];
	MOVBZ	R12,RL1
	EXTP	#PAG _koi8translation,#01h
	MOVB	RL1,[R12+#POF _koi8translation-128]
; convert_format.c   43	   break;
; convert_format.c   44	 }
_25:
; convert_format.c   45	 if (c<128) return(0); //Не русская буква
	MOVBZ	R12,RL1
	CMP	R12,#080h
	JMPR	cc_SGE,_27
_26:
	MOV	R4,#00h
	RETS
_27:
; convert_format.c   46	 return(ctype[c-128]);
	MOVBZ	R12,RL1
	EXTP	#PAG _ctype,#01h
	MOVB	RL1,[R12+#POF _ctype-128]
	MOVBZ	R4,RL1
; convert_format.c   47	}
_31:
	RETS
_GetCharType_x	ENDP
; convert_format.c   48	
; convert_format.c   49	unsigned int def_code (void);
; convert_format.c   50	
; convert_format.c   51	//Процедура форматирования текста
; convert_format.c   52	unsigned int ConvertFormat(int fin,int fs,int fmt)
; convert_format.c   53	{
	PUBLIC	_ConvertFormat
_ConvertFormat	PROC	FAR
	MOV	[-R0],R9
	MOV	[-R0],R8
	MOV	[-R0],R7
	MOV	[-R0],R6
	MOV	[-R0],R14
	MOV	[-R0],R12
	MOV	[-R0],R13
	SUB	R0,#0102h
; Locals:
;     ct = offset 2
; 
; Statics:
; 
; CSEs:
;     d = R8
;     pm = R15
;     c3 = RL6
;     c0 = RL7
;     s = R9
;     c = RL1
;     sl = R15
;     pp = R2
;     c1 = offset 0
;     c2 = offset 1
;     pg2 = R3
;     pg1 = R10
;     fs = offset 258
;     fin = offset 260
;     fmt = offset 262
;     &ustk + pp = R12R13
; 
; convert_format.c   54	 unsigned char c0;
; convert_format.c   55	 unsigned char c1=1; //Начать с пропуска символов
	MOVB	RL1,#01h
	MOVB	[R0],RL1
; convert_format.c   56	 unsigned char c2=1;
	MOVB	[R0+#01H],RL1
; convert_format.c   57	 unsigned char c3=32; //Начать с абзаца, раз у нас форматирование ;)
	MOVB	RL6,#020h
; convert_format.c   58	
; convert_format.c   59	 //unsigned int last_space;
; convert_format.c   60	 
; convert_format.c   61	 unsigned int sl;
; convert_format.c   62	
; convert_format.c   63	 unsigned int s;
; convert_format.c   64	 unsigned int d;
; convert_format.c   65	 char ct[256]; //Массив для описания типа символов
; convert_format.c   66	
; convert_format.c   67	
; convert_format.c   68	 d=0;
	MOV	R8,#00h
; convert_format.c   69	 ustk[d]=0;
	EXTP	#PAG _ustk,#01h
	MOVB	POF _ustk,ZEROS
; convert_format.c   70	 sl=0;
	MOV	R15,#00h
; convert_format.c   71	 //last_space=0xFFFF;
; convert_format.c   72	 s=FL_loader(fin,0xFFFF);
	MOV	R7,R15
	MOV	R13,#0FFFFh
	CALLS	SEG _FL_loader,_FL_loader
	MOV	R9,R4
	MOV	R15,R7
; convert_format.c   73	
; convert_format.c   74	 if (win_dos_koi==0xFF) win_dos_koi=def_code ();
	EXTP	#PAG _win_dos_koi,#01h
	MOVB	RL7,POF _win_dos_koi
	CMPB	RL7,#0FFh
	JMPR	cc_NE,_131
	MOV	R7,R15
	CALLS	SEG _def_code,_def_code
	EXTP	#PAG _win_dos_koi,#01h
	MOVB	POF _win_dos_koi,RL4
	MOV	R15,R7
_131:
; convert_format.c   75	
; convert_format.c   76	 //Подготавливаем массив ct
; convert_format.c   77	 c0=0;
	MOVB	RL7,#00h
; convert_format.c   78	 do
_132:
; convert_format.c   79	 {
; convert_format.c   80	  ct[c0]=GetCharType_x(c0);
	MOV	[-R0],R15
	MOVBZ	R12,RL7
	CALLS	SEG _GetCharType_x,_GetCharType_x
	MOVBZ	R12,RL7
	ADD	R12,R0
	MOVB	[R12+#04H],RL4
	MOV	R15,[R0+]
; convert_format.c   81	 }
; convert_format.c   82	 while(++c0);
	ADDB	RL7,#01h
	JMPR	cc_NZ,_132
; convert_format.c   83	
; convert_format.c   84	 #define GetCharType(VAR) (ct[VAR])
; convert_format.c   85	
; convert_format.c   86	 for(;;)
_133:
_134:
_135:
_136:
_137:
_138:
; convert_format.c   87	 {
; convert_format.c   88	  c0=c1;
	MOVB	RL7,[R0]
; convert_format.c   89	  c1=c2;
	MOVB	RL1,[R0+#01H]
	MOVB	[R0],RL1
; convert_format.c   90	  c2=c3;
	MOVB	[R0+#01H],RL6
; convert_format.c   91	  LSKIP1:
_139:
; convert_format.c   92	  c3=dstk[s++];
	MOV	R12,R9
	ADD	R9,#01h
	EXTP	#PAG _dstk,#01h
	MOVB	RL6,[R12+#POF _dstk]
; convert_format.c   93	  if (s>=8192) s=FL_loader(fin,s);
	CMP	R9,#02000h
	JMPR	cc_ULT,_140
	MOV	[-R0],R15
	MOV	R12,[R0+#0106H]
	MOV	R13,R9
	CALLS	SEG _FL_loader,_FL_loader
	MOV	R9,R4
	MOV	R15,[R0+]
_140:
; convert_format.c   94	  if (c3==9) c3=' '; //Замена табуляции на пробел
	CMPB	RL6,#09h
	JMPR	cc_NE,_141
	MOVB	RL6,#020h
_141:
; convert_format.c   95	  if (c3==1) c3=' '; //Замена служ. символов
	CMPB	RL6,#01h
	JMPR	cc_NE,_142
	MOVB	RL6,#020h
_142:
; convert_format.c   96	  if ((c3==' ')&&(c2==' ')) goto LSKIP1; //Пропуск пробелов
	CMPB	RL6,#020h
	JMPR	cc_NE,_143
	MOVB	RL1,[R0+#01H]
	CMPB	RL1,#020h
	JMPR	cc_EQ,_139
_143:
; convert_format.c   97	  if ((c3==13)&&(dstk[s]==10)) s++; //0D0A->0D
	CMPB	RL6,#0Dh
	JMPR	cc_NE,_145
	EXTP	#PAG _dstk,#01h
	MOVB	RL1,[R9+#POF _dstk]
	CMPB	RL1,#0Ah
	JMPR	cc_NE,_145
	ADD	R9,#01h
_145:
; convert_format.c   98	  if ((c3==10)&&(dstk[s]==13)) s++; //0A0D->0A
	CMPB	RL6,#0Ah
	JMPR	cc_NE,_147
	EXTP	#PAG _dstk,#01h
	MOVB	RL1,[R9+#POF _dstk]
	CMPB	RL1,#0Dh
	JMPR	cc_NE,_147
	ADD	R9,#01h
_147:
; convert_format.c   99	  if (c3==10) c3=13; //0A->0D
	CMPB	RL6,#0Ah
	JMPR	cc_NE,_148
	MOVB	RL6,#0Dh
_148:
; convert_format.c  100	  if (c0==0) goto LEOF; //Конец текста
	CMPB	RL7,#00h
	JMPA	cc_Z,_178
; convert_format.c  101	  if (fmt==1)
	MOV	R12,[R0+#0106H]
	CMP	R12,#01h
	JMPR	cc_NE,_155
; convert_format.c  102	  {
; convert_format.c  103	   if ((c0>' ')&&(c1=='-')&&(c2==13)&&(c3>' '))
	CMPB	RL7,#020h
	JMPR	cc_ULE,_151
	MOVB	RL1,[R0]
	CMPB	RL1,#02Dh
	JMPR	cc_NE,_151
	MOVB	RL2,[R0+#01H]
	CMPB	RL2,#0Dh
	JMPR	cc_NE,_151
	CMPB	RL6,#020h
	JMPA	cc_UGT,_156
; convert_format.c  104	   {
; convert_format.c  105	    //Удаление переноса
; convert_format.c  106	    c1=1;
; convert_format.c  107	    c2=1;
; convert_format.c  108	    goto LSYM;
; convert_format.c  109	   }
_151:
; convert_format.c  110	   if ((c0>' ')&&(c1==13)&&(c2>' '))
	CMPB	RL7,#020h
	JMPR	cc_ULE,_155
	MOVB	RL1,[R0]
	CMPB	RL1,#0Dh
	JMPR	cc_NE,_155
	MOVB	RL2,[R0+#01H]
	CMPB	RL2,#020h
	JMPR	cc_ULE,_155
; convert_format.c  111	   {
; convert_format.c  112	    //Замена перевода строки на пробел между словами
; convert_format.c  113	    c1=' ';
	MOVB	RL3,#020h
	MOVB	[R0],RL3
; convert_format.c  114	    goto LSYM;
	JMPR	cc_UC,_158
; convert_format.c  115	   }
; convert_format.c  116	  }
_155:
; convert_format.c  117	  if (c0==13)
	CMPB	RL7,#0Dh
	JMPR	cc_NE,_158
; convert_format.c  118	  {
; convert_format.c  119	    //Во всех других случаях перенос строки - это абзац
; convert_format.c  120		//last_space=0xFFFF;
; convert_format.c  121		sl=0;
	MOV	R15,#00h
; convert_format.c  122		d=FL_saver(fs,d); //Сливаем не слитое
	MOV	R7,R15
	MOV	R12,[R0+#0102H]
	MOV	R13,R8
	CALLS	SEG _FL_saver,_FL_saver
	MOV	R8,R4
	MOV	R15,R7
; convert_format.c  123	    ustk[d++]=0; //Конец строки
	MOVB	RL7,#00h
	MOV	R12,R8
	ADD	R8,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R12+#POF _ustk],RL7
; convert_format.c  124		curline++;
	EXTP	#PAG _curline,#02h
	SUB	POF _curline,ONES
	SUBC	POF (_curline+2),ONES
; convert_format.c  125	    if ((c1>' ')&&(fmt==2))
	MOVB	RL1,[R0]
	CMPB	RL1,#020h
	JMPA	cc_ULE,_138
	MOV	R12,[R0+#0106H]
	CMP	R12,#02h
	JMPA	cc_NE,_137
; convert_format.c  126	    {
; convert_format.c  127	     ustk[d++]=' '; //Если сл. символ - буква, добавляем отступ
	MOVB	RL2,#020h
	MOV	R13,R8
	ADD	R8,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R13+#POF _ustk],RL2
; convert_format.c  128	     sl++;
	MOV	R15,#01h
; convert_format.c  129	    }
; convert_format.c  130		continue;
	JMPA	cc_UC,_136
_156:
	MOVB	RL1,#01h
	MOVB	[R0],RL1
	MOVB	[R0+#01H],RL1
; convert_format.c  131	  }
; convert_format.c  132	  LSYM:
_158:
; convert_format.c  133	  if (c0!=1)
	CMPB	RL7,#01h
	JMPA	cc_EQ,_135
; convert_format.c  134	  {
; convert_format.c  135	   ustk[d]=c0;
	EXTP	#PAG _ustk,#01h
	MOVB	[R8+#POF _ustk],RL7
; convert_format.c  136	   //if ((c0==' ')&&sl) last_space=d; //Запоминаем последний пробел
; convert_format.c  137	   d++;
	ADD	R8,#01h
; convert_format.c  138	   sl++;
	ADD	R15,#01h
; convert_format.c  139	   if (sl>max_x)
	EXTP	#PAG _max_x,#01h
	CMP	R15,POF _max_x
	JMPA	cc_ULE,_134
; convert_format.c  140	   {
; convert_format.c  141	    //Слишком длинная строка, ищем, куда вставить перенос
; convert_format.c  142	    unsigned int pp=d+2; //Начинаем с конца c учетом доп. символов
	MOV	R2,R8
	ADD	R2,#02h
; convert_format.c  143	    unsigned int pg1=0xFFFF;
	MOV	R10,#0FFFFh
; convert_format.c  144	    unsigned int pg2=0xFFFF;
; convert_format.c  145	    char c;
; convert_format.c  146	    ustk[d]=c1;
	MOVB	RL1,[R0]
	EXTP	#PAG _ustk,#01h
	MOVB	[R8+#POF _ustk],RL1
; convert_format.c  147		ustk[d+1]=c2;
	MOVB	RL1,[R0+#01H]
	EXTP	#PAG _ustk,#02h
	MOVB	[R8+#POF _ustk+1],RL1
; convert_format.c  148		ustk[d+2]=c3;
	MOVB	[R8+#POF _ustk+2],RL6
; convert_format.c  149	    for(;;)
_159:
; convert_format.c  150	    {
; convert_format.c  151	     c=GetCharType(ustk[pp]);
	MOV	R12,#POF _ustk
	MOV	R13,#PAG _ustk
	ADD	R12,R2
	EXTP	R13,#01h
	MOVB	RL3,[R12]
	MOVBZ	R14,RL3
	ADD	R14,R0
	MOVB	RL1,[R14+#02H]
; convert_format.c  152		 if ((c==5)&&(pp<d))
	CMPB	RL1,#05h
	JMPR	cc_NE,_160
	CMP	R2,R8
	JMPA	cc_ULT,_176
; convert_format.c  153		 {
; convert_format.c  154		  //Нет подходящих пробелов, режем по живому ;)
; convert_format.c  155		  L_CUT:
; convert_format.c  156		  d--;
; convert_format.c  157		  d=FL_saver(fs,d);
; convert_format.c  158		  ustk[d++]=0;
; convert_format.c  159		  ustk[d++]=c0;
; convert_format.c  160		  sl=1;
; convert_format.c  161		  break;
; convert_format.c  162	     }
_160:
; convert_format.c  163	     if ((c==4)&&(pp<d))
	CMPB	RL1,#04h
	JMPR	cc_NE,_162
	CMP	R2,R8
	JMPR	cc_UGE,_162
; convert_format.c  164	     {
; convert_format.c  165		  //Режем по пробелу
; convert_format.c  166		  if (ustk[pp-1]<2) goto L_CUT; //Первый пробел не обрезаем
	EXTP	#PAG _ustk,#01h
	MOVB	RL1,[R2+#POF _ustk-1]
	CMPB	RL1,#02h
	JMPA	cc_ULT,_176
; convert_format.c  167		  ustk[pp]=0; //Обрезаем по пробелу и признак форматирования
	MOVB	RL7,#00h
	EXTP	R13,#01h
	MOVB	[R12],RL7
; convert_format.c  168		  sl=(d-pp)-1;
	MOV	R15,R8
	SUB	R15,R2
	SUB	R15,#01h
; convert_format.c  169		  d=FL_saver(fs,d); //Сливаем не слитое
	JMPA	cc_UC,_167
; convert_format.c  170		  //last_space=0xFFFF;
; convert_format.c  171	      break;
; convert_format.c  172	     }
_162:
; convert_format.c  173		 if ((c<1)||(c>3))
	CMPB	RL1,#01h
	JMPR	cc_ULT,_163
	CMPB	RL1,#03h
	JMPR	cc_ULE,_164
_163:
; convert_format.c  174		 {
; convert_format.c  175	      pg1=0xFFFF; //Новое слово
	MOV	R10,#0FFFFh
; convert_format.c  176	      pg2=0xFFFF;
; convert_format.c  177	     }
_164:
; convert_format.c  178	     if (c==2)
	CMPB	RL1,#02h
	JMPA	cc_NE,_174
; convert_format.c  179	     {
; convert_format.c  180	      pg2=pg1;
	MOV	R3,R10
; convert_format.c  181	      pg1=pp;
	MOV	R10,R2
; convert_format.c  182	      if (pg2!=0xFFFF)
	CMP	R3,#0FFFFh
	JMPA	cc_EQ,_174
; convert_format.c  183	      {
; convert_format.c  184	       //Нашли 2 гласных
; convert_format.c  185	       unsigned int pm=(pg2+pg1+1)>>1;
	MOV	R15,R3
	ADD	R15,R2
	ADD	R15,#01h
	SHR	R15,#01h
; convert_format.c  186	       if (GetCharType(ustk[pm])==3) pm++; //Если нельзя отрывать букву
	EXTP	#PAG _ustk,#01h
	MOVB	RL1,[R15+#POF _ustk]
	MOVBZ	R12,RL1
	ADD	R12,R0
	MOVB	RL1,[R12+#02H]
	CMPB	RL1,#03h
	JMPR	cc_NE,_165
	ADD	R15,#01h
_165:
; convert_format.c  187		   c=GetCharType(ustk[pm-2]);
	EXTP	#PAG _ustk,#01h
	MOVB	RL4,[R15+#POF _ustk-2]
	MOVBZ	R12,RL4
	ADD	R12,R0
	MOVB	RL1,[R12+#02H]
; convert_format.c  188	       if ((pm<(d-1))&&(c>0)&&(c<4))
	MOV	R12,R8
	SUB	R12,#01h
	CMP	R12,R15
	JMPA	cc_ULE,_174
	CMPB	RL1,#00h
	JMPA	cc_ULE,_174
	CMPB	RL1,#04h
	JMPA	cc_UGE,_174
; convert_format.c  189	       {
; convert_format.c  190		    if (pm==pg2)
	CMP	R15,R3
	JMPR	cc_NE,_166
; convert_format.c  191			{
; convert_format.c  192			 //Если гласная непостредственно справа, проверяем не одна ли она
; convert_format.c  193			 c=GetCharType(ustk[pg2+1]);
	EXTP	#PAG _ustk,#01h
	MOVB	RL4,[R3+#POF _ustk+1]
	MOVBZ	R12,RL4
	ADD	R12,R0
	MOVB	RL1,[R12+#02H]
; convert_format.c  194			 if ((c<1)||(c>3)) goto L_NOPERE;
	CMPB	RL1,#01h
	JMPR	cc_ULT,_174
	CMPB	RL1,#03h
	JMPR	cc_UGT,_174
; convert_format.c  195	        }
_166:
; convert_format.c  196	        memmove(ustk+(pm+2),ustk+pm,d-pm);
	MOV	R7,R15
	MOV	R12,R8
	SUB	R12,R7
	MOV	[-R0],R12
	MOV	R12,#POF _ustk+2
	MOV	R13,#PAG _ustk
	ADD	R12,R7
	MOV	R14,#POF _ustk
	MOV	R15,#PAG _ustk
	ADD	R14,R7
	CALLS	SEG _memmove,_memmove
	ADD	R0,#02h
	MOV	R15,R7
; convert_format.c  197	        ustk[pm++]='-';
	MOVB	RL7,#02Dh
	MOV	R12,R15
	ADD	R15,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R12+#POF _ustk],RL7
; convert_format.c  198			ustk[pm++]=0;
	MOVB	RL1,#00h
	MOV	R12,R15
	ADD	R15,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R12+#POF _ustk],RL1
; convert_format.c  199			d+=2; //Т.к. вставили 2 символа
	ADD	R8,#02h
; convert_format.c  200			sl=(d-pm);
	MOV	R12,R8
	SUB	R12,R15
	MOV	R15,R12
; convert_format.c  201		    d=FL_saver(fs,d); //Сливаем не слитое
_167:
	MOV	R7,R15
	MOV	R12,[R0+#0102H]
	MOV	R13,R8
	CALLS	SEG _FL_saver,_FL_saver
	MOV	R8,R4
	MOV	R15,R7
; convert_format.c  202			break;
	JMPR	cc_UC,_177
; convert_format.c  203			L_NOPERE:
; convert_format.c  204			;
; convert_format.c  205	       }
; convert_format.c  206	      }
; convert_format.c  207	     }
_174:
; convert_format.c  208	     pp--;
	SUB	R2,#01h
	JMPA	cc_UC,_159
_176:
	SUB	R8,#01h
	MOV	R12,[R0+#0102H]
	MOV	R13,R8
	CALLS	SEG _FL_saver,_FL_saver
	MOV	R8,R4
	MOVB	RL1,#00h
	MOV	R12,R8
	ADD	R8,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R12+#POF _ustk],RL1
	MOV	R12,R8
	ADD	R8,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R12+#POF _ustk],RL7
	MOV	R15,#01h
; convert_format.c  209	    }
_177:
; convert_format.c  210		curline++;
	EXTP	#PAG _curline,#02h
	SUB	POF _curline,ONES
	SUBC	POF (_curline+2),ONES
	JMPA	cc_UC,_133
; convert_format.c  211	   }
; convert_format.c  212	  }
; convert_format.c  213	 }
; convert_format.c  214	 LEOF:
_178:
; convert_format.c  215	 if (sl) //Не записана последняя строка
	CMP	R15,#00h
	JMPR	cc_Z,_179
; convert_format.c  216	 {
; convert_format.c  217	  ustk[d++]=0;
	MOVB	RL6,#00h
	MOV	R9,R8
	ADD	R8,#01h
	EXTP	#PAG _ustk,#01h
	MOVB	[R9+#POF _ustk],RL6
; convert_format.c  218	  curline++;
	EXTP	#PAG _curline,#02h
	SUB	POF _curline,ONES
	SUBC	POF (_curline+2),ONES
; convert_format.c  219	 }
_179:
; convert_format.c  220	 d=FL_saver(fs,d); //Сливаем не слитое
	MOV	R12,[R0+#0102H]
	MOV	R13,R8
	CALLS	SEG _FL_saver,_FL_saver
	MOV	R8,R4
; convert_format.c  221	 return(d);
; convert_format.c  222	}
	ADD	R0,#0108h
	MOV	R6,[R0+]
	MOV	R7,[R0+]
	MOV	R8,[R0+]
	MOV	R9,[R0+]
	RETS
_ConvertFormat	ENDP
; convert_format.c  223	
; convert_format.c  224	//-------------------------------------------------------------
; convert_format.c  225	// Автоматическое определение кодировки (по первой загрузке)
; convert_format.c  226	//-------------------------------------------------------------
; convert_format.c  227	/* Таблица сочетаний */
; convert_format.c  228	
; convert_format.c  229	static const unsigned char table_2s[128]={0xFF,0xFF,0xFF,0xC7,0xFE,0xBE,0xF7,0xFB,
CONVERT_FORMAT_2_PR	ENDS

CONVERT_FORMAT_1_FC	SECTION	DATA
_table_2s	LABEL	BYTE
	DB	0FFh,0FFh,0FFh,0C7h,0FEh
	DB	0BEh,0F7h,0FBh,0FDh,0BFh
	DB	0F7h,0F9h,0FCh,0BEh,0F1h
	DB	080h,0FFh,0FFh,0F7h,0BBh
	DB	0FFh,0FFh,0FFh,0CFh,0DEh
	DB	0BFh,0D1h,08h,0FFh,0BFh
	DB	0F1h,0BFh,0FFh,0FFh,0FFh
	DB	0C7h,01Dh,03Fh,07Fh,081h
	DB	0A7h,0B6h,0F2h,082h,0FFh
	DB	0FFh,075h,0DBh,0FCh,0BFh
	DB	0D7h,09Dh,0FFh,0AEh,0FBh
	DB	0DFh,0FFh,0FFh,0FFh,0C7h
	DB	084h,0B7h,0F3h,09Fh,0FFh
	DB	0FFh,0FFh,0DBh,0FFh,0BFh
	DB	0FFh,0FFh,0FDh,0BFh,0FFh
	DB	0FFh,0FFh,0FFh,0E7h,0C7h
	DB	084h,09Eh,0F0h,012h,0BCh
	DB	0BFh,0F0h,084h,0A4h,0BAh
	DB	010h,010h,0A4h,0BEh,0B8h
	DB	088h,0ACh,0BFh,0F7h,0Ah
	DB	084h,086h,090h,08h,04h
	DB	00h,00h,03h,07Fh,0FDh
	DB	0F7h,0C1h,07Dh,0AEh,06Fh
	DB	0CBh,015h,03Dh,0FCh,00h
	DB	07Fh,07Dh,0E7h,0C2h,07Fh
	DB	0FDh,0F7h,0C3h
; convert_format.c  230	 0xFD,0xBF,0xF7,0xF9,0xFC,0xBE,0xF1,0x80,0xFF,0xFF,0xF7,0xBB,0xFF,0xFF,0xFF,
; convert_format.c  231	 0xCF,0xDE,0xBF,0xD1,0x08,0xFF,0xBF,0xF1,0xBF,0xFF,0xFF,0xFF,0xC7,0x1D,0x3F,
; convert_format.c  232	 0x7F,0x81,0xA7,0xB6,0xF2,0x82,0xFF,0xFF,0x75,0xDB,0xFC,0xBF,0xD7,0x9D,0xFF,
; convert_format.c  233	 0xAE,0xFB,0xDF,0xFF,0xFF,0xFF,0xC7,0x84,0xB7,0xF3,0x9F,0xFF,0xFF,0xFF,0xDB,
; convert_format.c  234	 0xFF,0xBF,0xFF,0xFF,0xFD,0xBF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC7,0x84,0x9E,0xF0,
; convert_format.c  235	 0x12,0xBC,0xBF,0xF0,0x84,0xA4,0xBA,0x10,0x10,0xA4,0xBE,0xB8,0x88,0xAC,0xBF,
; convert_format.c  236	 0xF7,0x0A,0x84,0x86,0x90,0x08,0x04,0x00,0x00,0x03,0x7F,0xFD,0xF7,0xC1,0x7D,
; convert_format.c  237	 0xAE,0x6F,0xCB,0x15,0x3D,0xFC,0x00,0x7F,0x7D,0xE7,0xC2,0x7F,0xFD,0xF7,0xC3};
; convert_format.c  238	
; convert_format.c  239	/* =========================================================================
; convert_format.c  240	   Вспомогательная функция alt2num.
; convert_format.c  241	   Вход: a - код русской буквы в кодировке ALT.
; convert_format.c  242	   Выход: порядковый номер этой буквы (0-31).
; convert_format.c  243	 ========================================================================= */
; convert_format.c  244	unsigned int alt2num (int a)
; convert_format.c  245	{
	PUBLIC	_alt2num
CONVERT_FORMAT_1_FC	ENDS

CONVERT_FORMAT_2_PR	SECTION	CODE
_alt2num	PROC	FAR
; Locals:
; 
; Statics:
; 
; CSEs:
;     a = R12
; 
; convert_format.c  246	 if (a>=0xE0) a-=0x30;
	CMP	R12,#0E0h
	JMPR	cc_SLT,_180
	SUB	R12,#030h
_180:
; convert_format.c  247	 return (a&31);
	MOV	R4,R12
	AND	R4,#01Fh
; convert_format.c  248	}
	RETS
_alt2num	ENDP
; convert_format.c  249	/* =========================================================================
; convert_format.c  250	   Вспомогательная функция koi2num.
; convert_format.c  251	   Вход: a - код русской буквы в кодировке KOI.
; convert_format.c  252	   Выход: порядковый номер этой буквы (0-31).
; convert_format.c  253	 ========================================================================= */
; convert_format.c  254	unsigned int koi2num (int a)
; convert_format.c  255	{
	PUBLIC	_koi2num
CONVERT_FORMAT_2_PR	ENDS

CONVERT_FORMAT_1_FC	SECTION	DATA
_181	LABEL	BYTE
	DB	01Eh,00h,01h,016h,04h
	DB	05h,014h,03h,015h,08h
	DB	09h,0Ah,0Bh,0Ch,0Dh
	DB	0Eh,0Fh,01Fh,010h,011h
	DB	012h,013h,06h,02h,01Ch
	DB	01Bh,07h,018h,01Dh,019h
	DB	017h,01Ah
CONVERT_FORMAT_1_FC	ENDS

CONVERT_FORMAT_2_PR	SECTION	CODE
_koi2num	PROC	FAR
; Locals:
; 
; Statics:
;     t = label _181
; 
; CSEs:
;     a = R12
; 
; convert_format.c  256	 static const unsigned char t[32]={30,0,1,22,4,5,20,3,21,8,9,10,11,12,13,14,15,31,
; convert_format.c  257	  16,17,18,19,6,2,28,27,7,24,29,25,23,26};
; convert_format.c  258	 return (t[a&31]);
	AND	R12,#01Fh
	EXTP	#PAG _181,#01h
	MOVB	RL1,[R12+#POF _181]
	MOVBZ	R4,RL1
; convert_format.c  259	}
	RETS
_koi2num	ENDP
; convert_format.c  260	
; convert_format.c  261	/* =========================================================================
; convert_format.c  262	   Вспомогательная функция work_2s - обработка двухбуквенного сочетания.
; convert_format.c  263	   Вход:  с1 - порядковый номер первой буквы (0-31),
; convert_format.c  264	          c2 - порядковый номер второй буквы (0-31),
; convert_format.c  265	          check - надо ли проверять, встречалось ли сочетание раньше
; convert_format.c  266	                  (1 - да, 0 - нет),
; convert_format.c  267	          buf - адрес массива с информацией о встреченных сочетаниях.
; convert_format.c  268	   Выход: 0 - указанное сочетание уже встречалось раньше,
; convert_format.c  269	          1 - сочетание не встречалось раньше и является допустимым,
; convert_format.c  270	          2 - сочетание не встречалось раньше и является недопустимым.
; convert_format.c  271	 ========================================================================= */
; convert_format.c  272	
; convert_format.c  273	unsigned int work_2s (unsigned int c1, unsigned int c2, unsigned int check, unsigned char buf[128])
; convert_format.c  274	{
	PUBLIC	_work_2s
_work_2s	PROC	FAR
; Locals:
; 
; Statics:
; 
; CSEs:
;     mask = R12
;     i = R15
;     buf + i = R13R14
;     c2 = R13
;     check = R14
;     c1 = R12
;     buf = offset 0
; 
; convert_format.c  275	 unsigned int i=(c1<<2)+(c2>>3); /* Номер байта в массиве. */
	MOV	R15,R12
	SHL	R15,#02h
	MOV	R12,R13
	SHR	R12,#03h
	ADD	R15,R12
; convert_format.c  276	 unsigned int mask=0x80>>(c2&7); /* Маска, соответствующая номеру бита в байте. */
	AND	R13,#07h
	MOV	R1,#080h
	SHR	R1,R13
	MOV	R12,R1
; convert_format.c  277	
; convert_format.c  278	 /* Если check=1, проверяем: если соответствующий бит массива buf равен 0,
; convert_format.c  279	    значит, указанное сочетание уже встречалось раньше. Тогда выходим из
; convert_format.c  280	    функции, возвращая 0. Если же сочетание не встречалось, то помечаем, что
; convert_format.c  281	    оно встретилось (обнуляем соответствующий бит массива buf). */
; convert_format.c  282	
; convert_format.c  283	 if (check==1)
	CMP	R14,#01h
	JMPR	cc_NE,_183
; convert_format.c  284	 {
; convert_format.c  285	  if ((buf[i]&mask)==0) return (0);
	MOV	R13,[R0]
	MOV	R14,[R0+#02H]
	ADD	R13,R15
	EXTP	R14,#01h
	MOVB	RL1,[R13]
	MOVBZ	R1,RL1
	AND	R1,R12
	JMPR	cc_NZ,_182
	MOV	R4,#00h
	RETS
_182:
; convert_format.c  286	  buf[i]&=~mask;
	EXTP	R14,#01h
	MOVB	RL1,[R13]
	MOVBZ	R1,RL1
	MOV	R2,R12
	CPL	R2
	AND	R1,R2
	EXTP	R14,#01h
	MOVB	[R13],RL1
; convert_format.c  287	 }
_183:
; convert_format.c  288	
; convert_format.c  289	 /* Проверяем, допустимо сочетание или нет. */
; convert_format.c  290	
; convert_format.c  291	 if ((table_2s[i]&mask)!=0) return (1); /* Допустимо. */
	EXTP	#PAG _table_2s,#01h
	MOVB	RL1,[R15+#POF _table_2s]
	MOVBZ	R13,RL1
	AND	R13,R12
	JMPR	cc_Z,_184
	MOV	R4,#01h
	RETS
_184:
; convert_format.c  292	 return (2);                            /* Недопустимо. */
	MOV	R4,#02h
; convert_format.c  293	}
_186:
	RETS
_work_2s	ENDP
; convert_format.c  294	
; convert_format.c  295	/* =========================================================================
; convert_format.c  296	   Вспомогательная функция def_code - определение кодировки текста. Функции
; convert_format.c  297	   m_def_code и f_def_code - лишь надстройки над этой функцией.
; convert_format.c  298	   Вход:  get_char - указатель на функцию, которую надо вызывать для получения
; convert_format.c  299	                     очередного символа текста. Функция должна возвращать либо
; convert_format.c  300	                     код символа, либо, при достижении конца текста, -1.
; convert_format.c  301	          n - количество различных сочетаний русских букв (1-255), которого
; convert_format.c  302	              достаточно для определения кодировки.
; convert_format.c  303	   Выход: 0 - текст в кодировке ALT, 1 - WIN, 2 - KOI.
; convert_format.c  304	 ========================================================================= */
; convert_format.c  305	
; convert_format.c  306	unsigned int def_code (void)
; convert_format.c  307	{
	PUBLIC	_def_code
_def_code	PROC	FAR
	MOV	[-R0],R9
	MOV	[-R0],R8
	MOV	[-R0],R7
	MOV	[-R0],R6
	SUB	R0,#0108h
; Locals:
;     buf_1 = offset 8
;     buf_2 = offset 136
; 
; Statics:
; 
; CSEs:
;     c2 = R8
;     c1 = R9
;     all_3 = R6
;     all_1 = R7
;     bad_2 = offset 0
;     bad_3 = offset 2
;     bad_1 = offset 4
;     s = offset 6
;     b = R12
;     c = R13
;     a = R14
;     all_3 >> 5 = R12
; 
; convert_format.c  308	 /* В массиве buf_1 хранится информация о том, какие сочетания руских букв
; convert_format.c  309	    уже встречались в варианте ALT, а в массиве buf_2 - в варианте WIN. */
; convert_format.c  310	
; convert_format.c  311	 unsigned char buf_1 [128];
; convert_format.c  312	 unsigned char buf_2 [128];
; convert_format.c  313	
; convert_format.c  314	
; convert_format.c  315	 unsigned int s=0;
	MOV	R12,#00h
	MOV	[R0+#06H],R12
; convert_format.c  316	
; convert_format.c  317	 unsigned int bad_1=0;
	MOV	[R0+#04H],R12
; convert_format.c  318	 unsigned int bad_2=0;
	MOV	[R0],R12
; convert_format.c  319	 unsigned int bad_3=0;
	MOV	[R0+#02H],R12
; convert_format.c  320	 unsigned int all_1=0;
	MOV	R7,R12
; convert_format.c  321	 unsigned int all_3=0;  /* all_2=all_3 */
	MOV	R6,R12
; convert_format.c  322	
; convert_format.c  323	 unsigned int c1;
; convert_format.c  324	 unsigned int c2=0; /* Символы текущего обрабатываемого сочетания. */
	MOV	R8,R12
; convert_format.c  325	
; convert_format.c  326	 /* Инициализация buf_1 и buf_2. */
; convert_format.c  327	
; convert_format.c  328	 memset(buf_1,0xFF,sizeof(buf_1));
	MOV	R12,#08h
	ADD	R12,R0
	AND	R12,#03FFFh
	MOV	R13,DPP1
	MOV	R14,#0FFh
	MOV	R15,#080h
	CALLS	SEG _memset,_memset
; convert_format.c  329	 memset(buf_2,0xFF,sizeof(buf_2));
	MOV	R12,#088h
	ADD	R12,R0
	AND	R12,#03FFFh
	MOV	R13,DPP1
	MOV	R14,#0FFh
	MOV	R15,#080h
	CALLS	SEG _memset,_memset
; convert_format.c  330	
; convert_format.c  331	 /* Главный цикл - обработка сочетаний для каждого из трёх вариантов. Цикл
; convert_format.c  332	    выполняется, пока не кончится текст или в каком-либо из вариантов не
; convert_format.c  333	    встретится n сочетаний. */
; convert_format.c  334	
; convert_format.c  335	 while ((s<16384)&&(all_1<255)&&(all_3<255))
	JMPA	cc_UC,_206
_187:
; convert_format.c  336	 {
; convert_format.c  337	  c1=c2;
	MOV	R9,R8
; convert_format.c  338	  if ((c2=dstk[s])==0) break;
	MOV	R12,[R0+#06H]
	EXTP	#PAG _dstk,#01h
	MOVB	RL1,[R12+#POF _dstk]
	MOVBZ	R8,RL1
	JMPA	cc_Z,_209
; convert_format.c  339	  s++;
	ADD	R12,#01h
	MOV	[R0+#06H],R12
; convert_format.c  340	  /* Вариант ALT. Вначале проверяем, являются ли символы текущего сочетания
; convert_format.c  341	     кодами русских букв в кодировке ALT. */
; convert_format.c  342	
; convert_format.c  343	  if ((((c1>=0x80)&&(c1<0xB0))||((c1>=0xE0)&&(c1<0xF0)))&&
; convert_format.c  344	      (((c2>=0x80)&&(c2<0xB0))||((c2>=0xE0)&&(c2<0xF0))))
	CMP	R9,#080h
	JMPR	cc_ULT,_188
	CMP	R9,#0B0h
	JMPR	cc_ULT,_189
_188:
	CMP	R9,#0E0h
	JMPR	cc_ULT,_198
	CMP	R9,#0F0h
	JMPR	cc_UGE,_198
_189:
	CMP	R8,#080h
	JMPR	cc_ULT,_190
	CMP	R8,#0B0h
	JMPR	cc_ULT,_191
_190:
	CMP	R8,#0E0h
	JMPR	cc_ULT,_198
	CMP	R8,#0F0h
	JMPR	cc_UGE,_198
_191:
; convert_format.c  345	  {
; convert_format.c  346	   switch (work_2s(alt2num(c1),alt2num(c2),1,buf_1)) /* Обработали. */
	MOV	R12,#08h
	ADD	R12,R0
	AND	R12,#03FFFh
	MOV	R13,DPP1
	MOV	[-R0],R13
	MOV	[-R0],R12
	MOV	R12,R8
	CALLS	SEG _alt2num,_alt2num
	MOV	[-R0],R4
	MOV	R12,R9
	CALLS	SEG _alt2num,_alt2num
	MOV	R12,R4
	MOV	R14,#01h
	MOV	R13,[R0+]
	CALLS	SEG _work_2s,_work_2s
	ADD	R0,#04h
	CMP	R4,#02h
	JMPR	cc_EQ,_192
	CMP	R4,#01h
	JMPR	cc_EQ,_193
	JMPR	cc_UC,_198
; convert_format.c  347	   {
; convert_format.c  348	    case 2: bad_1++;
_192:
	MOV	R12,[R0+#04H]
	ADD	R12,#01h
	MOV	[R0+#04H],R12
; convert_format.c  349	    case 1: all_1++;
_193:
	ADD	R7,#01h
; convert_format.c  350	   }
; convert_format.c  351	  }
_198:
; convert_format.c  352	  /* Варианты WIN и KOI. Вначале проверяем, являются ли символы текущего
; convert_format.c  353	     сочетания кодами русских букв в этих кодировках (в обеих кодировках
; convert_format.c  354	     диапазоны кодов русских букв совпадают). */
; convert_format.c  355	
; convert_format.c  356	  if ((c1&c2)>=0xC0) /* Эквивалентно условию (c1>=0xC0)&&(c2>=0xC0). */
	MOV	R12,R9
	AND	R12,R8
	CMP	R12,#0C0h
	JMPR	cc_ULT,_206
; convert_format.c  357	  {
; convert_format.c  358	   switch (work_2s(c1&31,c2&31,1,buf_2)) /* Обработали. */
	MOV	R12,#088h
	ADD	R12,R0
	AND	R12,#03FFFh
	MOV	R13,DPP1
	MOV	[-R0],R13
	MOV	[-R0],R12
	MOV	R12,R9
	AND	R12,#01Fh
	MOV	R13,R8
	AND	R13,#01Fh
	MOV	R14,#01h
	CALLS	SEG _work_2s,_work_2s
	ADD	R0,#04h
	CMP	R4,#00h
	JMPR	cc_EQ,_206
	CMP	R4,#02h
	JMPR	cc_NE,_200
; convert_format.c  359	   {
; convert_format.c  360	    case 0: continue; /* Если сочетание букв уже встречалось в варианте WIN,
; convert_format.c  361	                         то оно уже встречалось и в варианте KOI, так что
; convert_format.c  362	                         пропускаем обработку варианта KOI и переходим
; convert_format.c  363	                         к следующей итерации главного цикла. */
; convert_format.c  364	    case 2: bad_2++;
_199:
	MOV	R12,[R0]
	ADD	R12,#01h
	MOV	[R0],R12
; convert_format.c  365	   }
_200:
; convert_format.c  366	
; convert_format.c  367	  /* Если сочетание букв ещё не встречалось в варианте WIN, то оно заведомо
; convert_format.c  368	     не встречалось и в варианте KOI, поэтому специально проверять это не
; convert_format.c  369	     надо - значит, функцию work_2s вызываем с параметром check, равным 0. */
; convert_format.c  370	
; convert_format.c  371	   switch (work_2s(koi2num(c1),koi2num(c2),0,NULL)) /* Обработали. */
	MOV	R12,#00h
	MOV	R13,#00h
	MOV	[-R0],R13
	MOV	[-R0],R12
	MOV	R12,R8
	CALLS	SEG _koi2num,_koi2num
	MOV	[-R0],R4
	MOV	R12,R9
	CALLS	SEG _koi2num,_koi2num
	MOV	R12,R4
	MOV	R14,#00h
	MOV	R13,[R0+]
	CALLS	SEG _work_2s,_work_2s
	ADD	R0,#04h
	CMP	R4,#02h
	JMPR	cc_EQ,_201
	CMP	R4,#01h
	JMPR	cc_EQ,_202
	JMPR	cc_UC,_206
; convert_format.c  372	   {
; convert_format.c  373	    case 2: bad_3++;
_201:
	MOV	R9,[R0+#02H]
	ADD	R9,#01h
	MOV	[R0+#02H],R9
; convert_format.c  374	    case 1: all_3++;
_202:
	ADD	R6,#01h
_206:
	MOV	R9,[R0+#06H]
	CMP	R9,#04000h
	JMPR	cc_UGE,_209
	CMP	R7,#0FFh
	JMPR	cc_UGE,_209
	CMP	R6,#0FFh
	JMPA	cc_ULT,_187
; convert_format.c  375	   }
; convert_format.c  376	  }
; convert_format.c  377	 }
_209:
; convert_format.c  378	
; convert_format.c  379	 /* Данные собраны. Теперь, если в каком-либо из вариантов недопустимых
; convert_format.c  380	    сочетаний не больше 1/32 от общего их числа, то считаем, что их и не
; convert_format.c  381	    было. */
; convert_format.c  382	
; convert_format.c  383	 if (bad_1<=(all_1>>5)) bad_1=0;
	MOV	R8,R7
	SHR	R8,#05h
	MOV	R9,[R0+#04H]
	CMP	R8,R9
	JMPR	cc_ULT,_210
	MOV	R8,#00h
	MOV	[R0+#04H],R8
_210:
; convert_format.c  384	 if (bad_2<=(all_3>>5)) bad_2=0;
	MOV	R12,R6
	SHR	R12,#05h
	MOV	R8,[R0]
	CMP	R12,R8
	JMPR	cc_ULT,_211
	MOV	R9,#00h
	MOV	[R0],R9
_211:
; convert_format.c  385	 if (bad_3<=(all_3>>5)) bad_3=0;
	MOV	R8,[R0+#02H]
	CMP	R12,R8
	JMPR	cc_ULT,_212
	MOV	R9,#00h
	MOV	[R0+#02H],R9
_212:
; convert_format.c  386	
; convert_format.c  387	 /* Получаем результат. */
; convert_format.c  388	
; convert_format.c  389	 {
; convert_format.c  390	  unsigned int a=((255-bad_1)<<8)+all_1;
	MOV	R8,[R0+#04H]
	MOV	R14,#0FFh
	SUB	R14,R8
	SHL	R14,#08h
	ADD	R14,R7
; convert_format.c  391	  unsigned int b=((255-bad_2)<<8)+all_3;
	MOV	R9,[R0]
	MOV	R12,#0FFh
	SUB	R12,R9
	SHL	R12,#08h
	ADD	R12,R6
; convert_format.c  392	  unsigned int c=((255-bad_3)<<8)+all_3;
	MOV	R7,[R0+#02H]
	MOV	R13,#0FFh
	SUB	R13,R7
	SHL	R13,#08h
	ADD	R13,R6
; convert_format.c  393	
; convert_format.c  394	  if ((a>=b)&&(a>=c)) return (0);
	CMP	R14,R12
	JMPR	cc_ULT,_214
	CMP	R14,R13
	JMPR	cc_ULT,_214
	MOV	R4,#00h
	JMPR	cc_UC,_217
_214:
; convert_format.c  395	  if (b>=c) return (1); else return (2);
	CMP	R12,R13
	JMPR	cc_ULT,_215
	MOV	R4,#01h
	JMPR	cc_UC,_217
_215:
	MOV	R4,#02h
; convert_format.c  396	 }
; convert_format.c  397	}
_217:
	ADD	R0,#0108h
	MOV	R6,[R0+]
	MOV	R7,[R0+]
	MOV	R8,[R0+]
	MOV	R9,[R0+]
	RETS
_def_code	ENDP
CONVERT_FORMAT_2_PR	ENDS

	EXTERN	_FL_loader:FAR
	EXTERN	_memmove:FAR
	EXTERN	_koi8translation:BYTE
	EXTERN	_curline:WORD
	EXTERN	_max_x:WORD
	EXTERN	_win_dos_koi:BYTE
	EXTERN	_memset:FAR
	EXTERN	_FL_saver:FAR
	EXTERN	_wintranslation:BYTE
	EXTERN	_dstk:BYTE
	EXTERN	_ustk:BYTE
	REGDEF	R0-R15
	END
